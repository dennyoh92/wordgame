<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í•œê¸€ ì›Œí”„ (Hangeul Word Warp)</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.7);
            --primary-color: #38bdf8;
            --secondary-color: #818cf8;
            --accent-color: #f472b6;
            --text-color: #f8fafc;
            --grid-size: 5;
            --cell-size: 80px;
        }

        @media (max-width: 480px) {
            :root {
                --cell-size: 65px;
            }

            #game-container {
                padding: 15px;
                border-radius: 16px;
            }

            header h1 {
                font-size: 1.8rem;
            }

            .cell {
                font-size: 1.2rem;
            }

            .input-group {
                flex-direction: column;
            }

            #active-word-display {
                gap: 5px;
            }
        }

        @media (max-width: 360px) {
            :root {
                --cell-size: 55px;
            }

            #game-grid {
                gap: 5px;
                padding: 5px;
            }

            .letter-block {
                padding: 4px 8px;
                font-size: 1rem;
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            /* Remove mobile tap highlight */
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
        }

        #game-container {
            width: 100%;
            max-width: 460px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            text-align: center;
            padding: 24px;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 5px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        header p {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-bottom: 20px;
        }



        #grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 25px;
        }

        #game-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 16px;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: default;
            transition: all 0.3s ease;
        }

        .cell.start {
            border: 2px solid var(--primary-color);
            background: rgba(56, 189, 248, 0.1);
        }

        .cell.target {
            border: 2px solid var(--accent-color);
            background: rgba(244, 114, 182, 0.1);
            animation: pulse 2s infinite;
            font-size: 2rem;
        }

        .cell.player {
            background: var(--primary-color);
            color: var(--bg-color);
            box-shadow: 0 0 20px var(--primary-color);
            transform: scale(1.1);
            z-index: 10;
        }

        .cell.active {
            background: rgba(129, 140, 248, 0.3);
            border-color: var(--secondary-color);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(244, 114, 182, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(244, 114, 182, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(244, 114, 182, 0);
            }
        }

        #control-panel {
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        #word-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 15px;
            color: white;
            font-size: 1rem;
            outline: none;
        }

        #word-input:focus {
            border-color: var(--primary-color);
        }

        #start-btn {
            background: var(--primary-color);
            color: var(--bg-color);
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            min-height: 48px;
        }

        #start-btn:hover {
            background: #7dd3fc;
        }

        .secondary-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 12px 15px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
        }

        .secondary-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .hint-text {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--secondary-color);
            font-weight: bold;
            min-height: 1.2em;
        }

        #active-word-display {
            display: flex;
            justify-content: center;
            gap: 10px;
            min-height: 40px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            /* Wrap for mobile */
        }

        .letter-block {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.3s;
        }

        .letter-block.current {
            background: var(--secondary-color);
            transform: translateY(-5px);
        }

        #message-display {
            font-size: 0.9rem;
            color: #94a3b8;
            min-height: 1.5em;
            margin-bottom: 10px;
        }

        #guide-panel {
            text-align: left;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 16px;
            font-size: 0.85rem;
        }

        #guide-panel h3 {
            margin-bottom: 10px;
            font-size: 1rem;
        }

        #guide-panel ul {
            list-style: none;
        }

        #guide-panel li {
            margin-bottom: 8px;
            color: #cbd5e1;
        }

        #action-panel {
            background: rgba(15, 23, 42, 0.5);
            padding: 15px;
            border-radius: 16px;
            border: 1px solid var(--primary-color);
            display: none;
            flex-direction: column;
            gap: 10px;
            margin: 15px auto;
            width: fit-content;
            min-width: 250px;
        }

        #action-panel h3 {
            margin-bottom: 10px;
            color: var(--text-color);
            font-size: 1.2rem;
        }

        .action-btn {
            background: var(--card-bg);
            border: 1px solid var(--secondary-color);
            color: white;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        .action-btn:hover:not(:disabled) {
            background: var(--secondary-color);
            color: var(--bg-color);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #475569;
        }

        .letter-block {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.3s;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .letter-block:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .letter-block.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
        }

        .letter-block.used {
            background: #475569;
            color: #94a3b8;
            opacity: 0.7;
            text-decoration: line-through;
            cursor: default;
        }

        #guide-panel li strong {
            color: var(--primary-color);
        }
    </style>
</head>

<body>
    <div id="game-container">
        <header>
            <h1>í•œê¸€ ì›Œí”„</h1>
            <p>ë‹¨ì–´ì˜ í˜ìœ¼ë¡œ ê³µê°„ì„ ë„ì•½í•˜ì„¸ìš”.</p>
        </header>



        <div id="grid-container">
            <script src="dictionary.js"></script>
            <script src="game.js" defer></script>
            <div id="game-grid"></div>
            <div id="constraint-badge"
                style="display: none; position: absolute; top: 10px; right: 10px; background: #ef4444; color: white; padding: 4px 10px; border-radius: 20px; font-size: 0.75rem; font-weight: bold; z-index: 10; box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);">
                3ê¸€ì ì œí•œ</div>
        </div>

        <div id="control-panel">
            <div class="input-group">
                <input type="text" id="word-input" placeholder="ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
                <button id="start-btn">ì‹œì‘</button>
                <button id="hint-btn" class="secondary-btn">ì •ë‹µ ì˜ˆì‹œ</button>
            </div>

            <div id="action-panel">
                <h3 id="action-title">ì„ íƒ: ?</h3>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button id="btn-warp" class="action-btn" style="flex: 1;">ììŒ ì›Œí”„ (Warp)</button>
                    <button id="btn-move" class="action-btn" style="flex: 1;">ëª¨ìŒ ì´ë™ (Move)</button>
                </div>
            </div>
            <div id="active-word-display"></div>
            <div id="message-display">ê²©ì ìœ„ì˜ ììŒì„ ë³´ê³  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</div>
            <div id="hint-display" class="hint-text"></div>

            <div id="guide-panel">
                <h3>ì¡°ì‘ ê°€ì´ë“œ</h3>
                <div
                    style="font-size: 0.8rem; color: var(--secondary-color); margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px;">
                    <strong>ììŒ ì›Œí”„:</strong> ì´ˆì„± â†” ì¢…ì„± ìœ„ì¹˜ë¥¼ ë²ˆê°ˆì•„ ì´ë™ (ë°›ì¹¨ í•„ìˆ˜)
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 0.75rem;">
                    <div>ã…, ã… : ì˜¤ë¥¸ìª½ 1ì¹¸ (â†’)</div>
                    <div>ã…‘ : ì˜¤ë¥¸ìª½ 2ì¹¸ (â‡‰)</div>
                    <div>ã…“, ã…” : ì™¼ìª½ 1ì¹¸ (â†)</div>
                    <div>ã…• : ì™¼ìª½ 2ì¹¸ (â‡‡)</div>
                    <div>ã…—, ã…š : ìœ„ìª½ 1ì¹¸ (â†‘)</div>
                    <div>ã…› : ìœ„ìª½ 2ì¹¸ (â‡ˆ)</div>
                    <div>ã…œ, ã…Ÿ : ì•„ë˜ìª½ 1ì¹¸ (â†“)</div>
                    <div>ã…  : ì•„ë˜ìª½ 2ì¹¸ (â‡Š)</div>
                    <div>ã…˜ : ìš°ì¸¡ ìƒë‹¨ (â†—)</div>
                    <div>ã… : ì¢Œì¸¡ í•˜ë‹¨ (â†™)</div>
                </div>
            </div>
        </div>

        <script>
            /**
             * Hangeul Word Warp
             * Core Logic and Engine
             */

            const CONSONANTS = ['ã„±', 'ã„´', 'ã„·', 'ã„¹', 'ã…', 'ã…‚', 'ã……', 'ã…‡', 'ã…ˆ', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
            const CHO = ['ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
            const JUNG = ['ã…', 'ã…', 'ã…‘', 'ã…’', 'ã…“', 'ã…”', 'ã…•', 'ã…–', 'ã…—', 'ã…˜', 'ã…™', 'ã…š', 'ã…›', 'ã…œ', 'ã…', 'ã…', 'ã…Ÿ', 'ã… ', 'ã…¡', 'ã…¢', 'ã…£'];
            const JONG = ['', 'ã„±', 'ã„²', 'ã„³', 'ã„´', 'ã„µ', 'ã„¶', 'ã„·', 'ã„¹', 'ã„º', 'ã„»', 'ã„¼', 'ã„½', 'ã„¾', 'ã„¿', 'ã…€', 'ã…', 'ã…‚', 'ã…„', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];

            const DICTIONARY = [
                'ë¬¼ì‚´', 'ë¶ìª½', 'í•™ê¸°', 'ê³¼í•™', 'ë¬¼í•™', 'ìˆ˜ë°•', 'í•™êµ', 'ë°”ë‹¤', 'ì¶•êµ¬', 'ì‚¬ì', 'ê¸°ì°¨', 'í•˜ëŠ˜', 'í¬ë„', 'ëª¨ì', 'ë‚˜ë¬´', 'ë‚˜ë¹„', 'ìš°ìœ ', 'ì•„ì´', 'ì˜¤ì´',
                'ê°•ë¬¼', 'êµ¬ë¦„', 'ë³„ë¹›', 'ë‹¬ë¹›', 'í–‡ì‚´', 'ë°”ëŒ', 'ì†Œë¦¬', 'ë…¸ë˜', 'ê·¸ë¦¼', 'í¸ì§€', 'ì¹œêµ¬', 'ì‚¬ë‘', 'í–‰ë³µ', 'ë¯¸ì†Œ', 'ê¸°ì¨', 'ìŠ¬í””', 'ìš©ê¸°', 'í¬ë§',
                'ì‚¬ê³¼', 'ì°¸ì™¸', 'ë”¸ê¸°', 'ìˆ˜ë°•', 'í¬ë„', 'ê·¤', 'ì˜¤ë Œì§€', 'ë°”ë‚˜ë‚˜', 'ë§ê³ ', 'ë ˆëª¬', 'ë¼ì„', 'í‚¤ìœ„', 'ìë‘', 'ë³µìˆ­ì•„', 'ì•µë‘', 'ë³´ë¦¬', 'ë²¼',
                'í•œêµ­', 'ì„œìš¸', 'ë¶€ì‚°', 'ëŒ€êµ¬', 'ì¸ì²œ', 'ê´‘ì£¼', 'ëŒ€ì „', 'ìš¸ì‚°', 'ì„¸ì¢…', 'ê²½ê¸°', 'ê°•ì›', 'ì¶©ë¶', 'ì¶©ë‚¨', 'ì „ë¶', 'ì „ë‚¨', 'ê²½ë¶', 'ê²½ë‚¨', 'ì œì£¼'
            ];

            class HangeulParser {
                static decompose(syllable) {
                    const code = syllable.charCodeAt(0) - 44032;
                    if (code < 0 || code > 11171) return null;

                    const jongIdx = code % 28;
                    const jungIdx = ((code - jongIdx) / 28) % 21;
                    const choIdx = (((code - jongIdx) / 28) - jungIdx) / 21;

                    return {
                        cho: CHO[choIdx],
                        jung: JUNG[jungIdx],
                        jong: JONG[jongIdx]
                    };
                }
            }

            class GameEngine {
                constructor() {
                    this.gridSize = 5;
                    this.grid = [];
                    this.playerPos = { x: 0, y: 0 };
                    this.targetPos = { x: 4, y: 4 };
                    this.startPos = { x: 0, y: 0 }; // Track start for reset

                    this.currentWord = "";
                    this.letterStates = []; // { char, status: 'unused'|'used', index }
                    this.selectedBlockIndex = -1;
                    this.wordLengthLimit = null; // null or 3

                    this.isInputLocked = false;
                    this.isWarping = false; // Waiting for target click

                    this.externalDictionary = new Set();
                    this.isDictLoaded = false;

                    this.init();
                }

                init() {
                    this.loadDictionary(); // Start loading
                    this.generateSolvableLevel();
                    this.setupDOM();
                    this.render();
                }

                async loadDictionary() {
                    // Try to load from window.hangeulDictionary (loaded via script tag)
                    if (window.hangeulDictionary && Array.isArray(window.hangeulDictionary)) {
                        this.externalDictionary = new Set(window.hangeulDictionary);
                        this.isDictLoaded = true;
                        console.log(`Loaded ${window.hangeulDictionary.length} words from dictionary.js`);
                        this.showMessage("ì‚¬ì „ ë°ì´í„° ë¡œë“œ ì™„ë£Œ!");
                        document.getElementById('start-btn').textContent = "ê²Œì„ ì‹œì‘";
                        document.getElementById('start-btn').disabled = false;
                    } else {
                        // Fallback: Try fetch for json (in case running on server)
                        try {
                            const response = await fetch('dictionary.json');
                            if (!response.ok) throw new Error("Dictionary not found");
                            const words = await response.json();
                            this.externalDictionary = new Set(words);
                            this.isDictLoaded = true;
                            this.showMessage("ì‚¬ì „ ë°ì´í„° ë¡œë“œ ì™„ë£Œ!");
                            document.getElementById('start-btn').textContent = "ê²Œì„ ì‹œì‘";
                            document.getElementById('start-btn').disabled = false;
                        } catch (e) {
                            console.warn("Failed to load dictionary.", e);
                            this.showMessage("ì‚¬ì „ ë¡œë“œ ì‹¤íŒ¨. ì˜¬ë°”ë¥¸ ë‹¨ì–´ í™•ì¸ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.");
                            // Allow start anyway? Or block?
                            // Let's allow start but keep isDictLoaded false so we know checking is disabled?
                            // User wants VALIDATION. If missing, we should probably warn strongly.
                            document.getElementById('start-btn').textContent = "ì‚¬ì „ ì—†ì´ ì‹œì‘ (ê²€ì¦ ë¶ˆê°€)";
                            document.getElementById('start-btn').disabled = false;
                        }
                    }
                }

                isValidWord(word) {
                    // 1. If external dict loaded, check it
                    if (this.isDictLoaded) {
                        return this.externalDictionary.has(word);
                    }
                    // 2. Fallback to basic dictionary (optional, or just allow all if dict missing?)
                    // For now, let's just warn if dict missing but still use internal for recommendation
                    // If user specifically requested strict validation, we might want to be strict.
                    // But without the file, game becomes unplayable if strict.
                    // So: If dict NOT loaded, allow any >=2 inputs? Or basic dict?
                    // User requirement: "input actual words".
                    // If dict is missing, we can't truly validate.
                    // Let's fallback to internal DICTIONARY for minimal check, or allow all with warning.
                    return true;
                }

                generateSolvableLevel() {
                    let attempts = 0;
                    let bestLevel = null;
                    let minPenalty = Infinity;

                    // 50% chance to set 3-letter limit
                    this.wordLengthLimit = Math.random() < 0.5 ? 3 : null;

                    while (attempts < 200) {
                        attempts++;
                        this.randomizePoints();
                        this.createGrid();

                        const solutions = this.findSolutions();
                        if (solutions.length > 0) {
                            // Evaluate solutions for "cleanliness" around target
                            for (const sol of solutions) {
                                const path = this.simulateWord(sol);
                                const penalty = this.calculatePathPenalty(path);

                                if (penalty < minPenalty) {
                                    minPenalty = penalty;
                                    bestLevel = {
                                        grid: JSON.parse(JSON.stringify(this.grid)),
                                        playerPos: { ...this.playerPos },
                                        targetPos: { ...this.targetPos },
                                        path: path,
                                        limit: this.wordLengthLimit
                                    };
                                }
                            }

                            // If we found a perfect solution (penalty 0), we can stop early
                            if (minPenalty === 0) break;
                        }
                    }

                    if (bestLevel) {
                        this.grid = bestLevel.grid;
                        this.playerPos = bestLevel.playerPos;
                        this.targetPos = bestLevel.targetPos;
                        this.wordLengthLimit = bestLevel.limit;
                        this.pruneGrid(bestLevel.path);

                        if (this.wordLengthLimit) {
                            this.showMessage(`3ê¸€ì ì œí•œ ë¼ìš´ë“œ! (ì˜ˆ: ${bestLevel.path.slice(0, 3).map(p => this.grid[p.y][p.x]).join('')}...)`);
                            // Note: showMessage will be overridden by initial prompt, so update UI specifically
                        }
                    } else {
                        console.warn("í’€ ìˆ˜ ìˆëŠ” ë ˆë²¨ì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
                        // Retry once more without limit if fails? No, just log for now
                    }
                }

                calculatePathPenalty(path) {
                    if (!path) return Infinity;
                    let penalty = 0;
                    path.forEach(pos => {
                        const dist = Math.abs(pos.x - this.targetPos.x) + Math.abs(pos.y - this.targetPos.y);
                        if (dist === 1) penalty += 10; // High penalty for using cell adjacent to target
                    });
                    return penalty;
                }

                pruneGrid(path) {
                    if (!path) return;

                    const used = new Set(path.map(p => `${p.x},${p.y}`));

                    // 1. Force remove all target adjacents if they are NOT in path
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (Math.abs(dx) + Math.abs(dy) !== 1) continue; // Only orthogonal
                            const nx = this.targetPos.x + dx;
                            const ny = this.targetPos.y + dy;
                            if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {
                                if (!used.has(`${nx},${ny}`)) {
                                    this.grid[ny][nx] = "";
                                }
                            }
                        }
                    }

                    // 2. Continue pruning other cells, prioritizing those farthest from the target
                    const candidates = [];
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            if (x === this.targetPos.x && y === this.targetPos.y) continue;
                            if (this.grid[y][x] !== "" && !used.has(`${x},${y}`)) {
                                candidates.push({ x, y });
                            }
                        }
                    }

                    // Sort by distance from targetPos (farther first)
                    candidates.sort((a, b) => {
                        const distA = Math.abs(a.x - this.targetPos.x) + Math.abs(a.y - this.targetPos.y);
                        const distB = Math.abs(b.x - this.targetPos.x) + Math.abs(b.y - this.targetPos.y);
                        return distB - distA; // Descending distance
                    });

                    // Aim for about 50-60% empty grid total? Or just keep removing up to a limit
                    const alreadyRemoved = this.grid.flat().filter(c => c === "").length - 1; // -1 for target
                    const maxToRemove = 15 - alreadyRemoved;

                    if (maxToRemove > 0) {
                        const extraRemove = candidates.slice(0, maxToRemove);
                        extraRemove.forEach(pos => {
                            this.grid[pos.y][pos.x] = "";
                        });
                    }
                }

                randomizePoints() {
                    // Randomize start and target with at least 3 distance (Manhattan)
                    do {
                        this.playerPos = {
                            x: Math.floor(Math.random() * this.gridSize),
                            y: Math.floor(Math.random() * this.gridSize)
                        };
                        this.targetPos = {
                            x: Math.floor(Math.random() * this.gridSize),
                            y: Math.floor(Math.random() * this.gridSize)
                        };
                    } while (Math.abs(this.playerPos.x - this.targetPos.x) + Math.abs(this.playerPos.y - this.targetPos.y) < 3);
                }

                createGrid() {
                    this.grid = [];
                    for (let y = 0; y < this.gridSize; y++) {
                        const row = [];
                        for (let x = 0; x < this.gridSize; x++) {
                            // Target cell has no consonant
                            if (x === this.targetPos.x && y === this.targetPos.y) {
                                row.push("");
                            } else {
                                const randomConsonant = CONSONANTS[Math.floor(Math.random() * CONSONANTS.length)];
                                row.push(randomConsonant);
                            }
                        }
                        this.grid.push(row);
                    }
                }

                setupDOM() {
                    this.gridEl = document.getElementById('game-grid');
                    this.inputEl = document.getElementById('word-input');
                    this.startBtn = document.getElementById('start-btn');
                    this.messageEl = document.getElementById('message-display');
                    this.wordDisplayEl = document.getElementById('active-word-display');

                    this.hintBtn = document.getElementById('hint-btn');
                    this.hintDisplayEl = document.getElementById('hint-display');

                    // Action Panel
                    this.actionPanel = document.getElementById('action-panel');
                    this.actionTitle = document.getElementById('action-title');
                    this.btnWarp = document.getElementById('btn-warp');
                    this.btnMove = document.getElementById('btn-move');
                    this.constraintBadge = document.getElementById('constraint-badge');

                    this.startBtn.onclick = () => this.handleStart();
                    this.hintBtn.onclick = () => this.showHint();
                    this.inputEl.onkeypress = (e) => {
                        if (e.key === 'Enter') this.handleStart();
                    };



                    // Grid Click
                    this.gridEl.onclick = (e) => {
                        const cell = e.target.closest('.cell');
                        if (!cell) return;

                        if (this.isWarping) {
                            const idx = Array.from(this.gridEl.children).indexOf(cell);
                            const x = idx % this.gridSize;
                            const y = Math.floor(idx / this.gridSize);

                            // Check if valid target
                            if (cell.classList.contains('active')) {
                                this.resolveWarp({ x, y });
                            }
                        }
                    };

                    // Action Buttons
                    this.btnWarp.onclick = () => this.initiateWarp();
                    this.btnMove.onclick = () => this.initiateMove();
                }

                render() {
                    this.gridEl.innerHTML = '';
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            cell.textContent = this.grid[y][x];

                            if (x === this.playerPos.x && y === this.playerPos.y) {
                                cell.classList.add('player');
                            }
                            if (x === this.targetPos.x && y === this.targetPos.y) {
                                cell.classList.add('target');
                            }
                            // Only show start label if it's the very first render or we still care about starting pos
                            // Let's use a one-time class if needed, but for now just player pos

                            this.gridEl.appendChild(cell);
                        }
                    }

                }

                async handleStart() {
                    if (this.isInputLocked && this.letterStates.length > 0) return;

                    const word = this.inputEl.value.trim();
                    if (!word) {
                        this.showMessage("ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”!");
                        return;
                    }

                    if (this.wordLengthLimit && word.length !== this.wordLengthLimit) {
                        this.showMessage(`${this.wordLengthLimit}ê¸€ì ë‹¨ì–´ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤!`);
                        return;
                    }

                    if (word.length < 2) { // This check is still relevant if wordLengthLimit is null
                        this.showMessage("ë‹¨ì–´ëŠ” ìµœì†Œ 2ê¸€ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤!");
                        return;
                    }

                    // Validate Word
                    if (this.isDictLoaded && !this.isValidWord(word)) {
                        this.showMessage(`'${word}'ì€(ëŠ”) ì‚¬ì „ì— ì—†ëŠ” ë‹¨ì–´ì…ë‹ˆë‹¤.`);
                        return;
                    }

                    this.startPos = { ...this.playerPos };
                    this.currentWord = word;

                    // Initialize Letter States
                    this.letterStates = Array.from(word).map((char, index) => ({
                        char,
                        index,
                        status: 'unused', // unused, used
                        decomposed: HangeulParser.decompose(char)
                    }));

                    this.isInputLocked = true;
                    this.inputEl.disabled = true;
                    this.startBtn.textContent = "ë‹¤ì‹œ í•˜ê¸°";
                    this.startBtn.onclick = () => this.resetGame();

                    this.renderWordBlocks();
                    this.showMessage("ê²©ì ìœ„ì˜ ììŒê³¼ ì¼ì¹˜í•˜ëŠ” ê¸€ìë¥¼ í´ë¦­í•˜ì„¸ìš”.");
                    this.isWarping = false;
                    this.hideActionPanel();
                }

                resetGame() {
                    this.isInputLocked = false;
                    this.inputEl.disabled = false;
                    this.startBtn.textContent = "ì‹œì‘";
                    this.startBtn.onclick = () => this.handleStart();
                    this.letterStates = [];
                    this.resetToStartPos();
                    this.renderWordBlocks();
                    this.hideActionPanel();
                    this.clearHighlights();
                    this.showMessage("ê²©ì ìœ„ì˜ ììŒì„ ë³´ê³  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
                }

                resetToStartPos() {
                    this.playerPos = { ...this.startPos };
                    this.render();
                }

                resetToStartAndRetry() {
                    this.showMessage("ì¡°ê±´ ë¶ˆì¼ì¹˜! ì²˜ìŒ ìœ„ì¹˜ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.");
                    this.resetToStartPos();
                    // Reset states
                    this.letterStates.forEach(s => s.status = 'unused');
                    this.renderWordBlocks();
                    this.hideActionPanel();
                    this.clearHighlights();
                    this.isWarping = false;
                }

                startNewLevel() {
                    this.initGame();
                }

                initGame() {
                    this.inputEl.value = "";
                    this.wordDisplayEl.innerHTML = "";
                    this.generateSolvableLevel();
                    this.startPos = { ...this.playerPos };
                    this.render();

                    if (this.wordLengthLimit) {
                        this.constraintBadge.style.display = 'block';
                        this.showMessage(`${this.wordLengthLimit}ê¸€ì ë‹¨ì–´ë¡œ ëª©í‘œì— ë„ë‹¬í•˜ì„¸ìš”!`);
                    } else {
                        this.constraintBadge.style.display = 'none';
                        this.showMessage("ê²©ì ìœ„ì˜ ììŒì„ ë³´ê³  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
                    }
                }

                showHint() {
                    const solutions = this.findSolutions();
                    if (solutions.length > 0) {
                        // Show the shortest or first valid solution
                        const best = solutions.sort((a, b) => a.length - b.length)[0];
                        this.hintDisplayEl.textContent = `ì¶”ì²œ ë‹¨ì–´: ${best}`;
                    } else {
                        this.hintDisplayEl.textContent = "í˜„ì¬ ìœ„ì¹˜ì—ì„œ ë„ë‹¬ ê°€ëŠ¥í•œ ë‹¨ì–´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.";
                    }
                }

                findSolutions() {
                    const results = [];
                    const dict = this.isDictLoaded ? Array.from(this.externalDictionary) : DICTIONARY;

                    for (const word of dict) {
                        if (this.wordLengthLimit && word.length !== this.wordLengthLimit) continue;
                        if (word.length >= 2 && this.simulateWord(word)) { // Keep word.length >= 2 for when wordLengthLimit is null
                            results.push(word);
                        }
                    }
                    return results;
                }

                simulateWord(word) {
                    let tempPos = { x: this.playerPos.x, y: this.playerPos.y };
                    const path = []; // Track used coordinates

                    for (let i = 0; i < word.length; i++) {
                        const char = word[i];
                        const decomposed = HangeulParser.decompose(char);
                        if (!decomposed) return null;

                        // Current cell used
                        path.push({ x: tempPos.x, y: tempPos.y });

                        const currentConsonant = this.grid[tempPos.y][tempPos.x];
                        const canActivate = (currentConsonant === decomposed.cho || (decomposed.jong && currentConsonant === decomposed.jong));
                        if (!canActivate) return null;

                        // Simulate Warp
                        if (decomposed.jong) {
                            let targetConsonant = "";
                            if (currentConsonant === decomposed.cho) targetConsonant = decomposed.jong;
                            else if (currentConsonant === decomposed.jong) targetConsonant = decomposed.cho;

                            if (targetConsonant) {
                                const potentialTargets = [];
                                for (let y = 0; y < this.gridSize; y++) {
                                    for (let x = 0; x < this.gridSize; x++) {
                                        if (this.grid[y][x] === targetConsonant && (x !== tempPos.x || y !== tempPos.y)) {
                                            potentialTargets.push({ x, y });
                                        }
                                    }
                                }
                                if (potentialTargets.length > 0) {
                                    // In simulation, we need to know if ANY of these paths lead to victory.
                                    // For simplicity, let's assume the "best" jump (closest to goal).
                                    potentialTargets.sort((a, b) => {
                                        const distA = Math.abs(a.x - this.targetPos.x) + Math.abs(a.y - this.targetPos.y);
                                        const distB = Math.abs(b.x - this.targetPos.x) + Math.abs(b.y - this.targetPos.y);
                                        return distA - distB;
                                    });
                                    tempPos = { x: potentialTargets[0].x, y: potentialTargets[0].y };
                                    // Warp target used
                                    path.push({ x: tempPos.x, y: tempPos.y });
                                }
                            }
                        }

                        // Simulate Vowel Move
                        let dx = 0, dy = 0;
                        const vowel = decomposed.jung;
                        switch (vowel) {
                            case 'ã…': case 'ã…': dx = 1; break;
                            case 'ã…‘': dx = 2; break;
                            case 'ã…“': case 'ã…”': dx = -1; break;
                            case 'ã…•': dx = -2; break;
                            case 'ã…—': case 'ã…š': dy = -1; break;
                            case 'ã…›': dy = -2; break;
                            case 'ã…œ': case 'ã…Ÿ': dy = 1; break;
                            case 'ã… ': dy = 2; break;
                            case 'ã…˜': dx = 1; dy = -1; break;
                            case 'ã…': dx = -1; dy = 1; break;
                        }
                        tempPos.x = Math.max(0, Math.min(this.gridSize - 1, tempPos.x + dx));
                        tempPos.y = Math.max(0, Math.min(this.gridSize - 1, tempPos.y + dy));

                        if (tempPos.x === this.targetPos.x && tempPos.y === this.targetPos.y) {
                            return path;
                        }
                    }
                    return null;
                }

                renderWordBlocks() {
                    this.wordDisplayEl.innerHTML = '';
                    this.letterStates.forEach(state => {
                        const block = document.createElement('div');
                        block.className = `letter-block ${state.status}`;
                        if (this.selectedBlockIndex === state.index) block.classList.add('selected');
                        block.textContent = state.char;

                        block.onclick = () => {
                            if (state.status === 'used') return;
                            this.selectBlock(state.index);
                        };

                        this.wordDisplayEl.appendChild(block);
                    });
                }

                selectBlock(index) {
                    if (this.isWarping) return; // Busy

                    this.selectedBlockIndex = index;
                    this.renderWordBlocks();

                    const state = this.letterStates[index];
                    const dec = state.decomposed;

                    if (!dec) {
                        this.showMessage("ìœ íš¨í•˜ì§€ ì•Šì€ ê¸€ìì…ë‹ˆë‹¤.");
                        return;
                    }

                    this.actionTitle.textContent = `ì„ íƒ: '${state.char}'`;
                    this.actionPanel.style.display = 'flex';

                    // Validate Actions
                    const currentConsonant = this.grid[this.playerPos.y][this.playerPos.x];
                    const canActivate = (currentConsonant === dec.cho || (dec.jong && currentConsonant === dec.jong));

                    if (!canActivate) {
                        this.showMessage("í˜„ì¬ ìœ„ì¹˜ì˜ ììŒê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤!");
                        this.btnWarp.disabled = true;
                        this.btnMove.disabled = true;
                    } else {
                        this.showMessage("í–‰ë™ì„ ì„ íƒí•˜ì„¸ìš”.");
                        // Check Warp
                        let canWarp = false;
                        if (dec.jong) {
                            // Check if target exists
                            let targetConsonant = "";
                            if (currentConsonant === dec.cho) targetConsonant = dec.jong;
                            else if (currentConsonant === dec.jong) targetConsonant = dec.cho;

                            if (targetConsonant) {
                                // Check grid for targets
                                const targets = this.findWarpTargets(targetConsonant);
                                if (targets.length > 0) canWarp = true;
                            }
                        }
                        this.btnWarp.disabled = !canWarp;

                        // Check Move (always possible if activatable?)
                        this.btnMove.disabled = false;
                    }
                }

                hideActionPanel() {
                    this.actionPanel.style.display = 'none';
                    this.selectedBlockIndex = -1;
                    this.renderWordBlocks();
                }

                findWarpTargets(targetConsonant) {
                    const targets = [];
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            if (this.grid[y][x] === targetConsonant && (x !== this.playerPos.x || y !== this.playerPos.y)) {
                                targets.push({ x, y });
                            }
                        }
                    }
                    return targets;
                }

                initiateWarp() {
                    const state = this.letterStates[this.selectedBlockIndex];
                    const dec = state.decomposed;
                    const currentConsonant = this.grid[this.playerPos.y][this.playerPos.x];

                    let targetConsonant = "";
                    if (currentConsonant === dec.cho) targetConsonant = dec.jong;
                    else targetConsonant = dec.cho;

                    const targets = this.findWarpTargets(targetConsonant);
                    if (targets.length === 0) return;

                    this.showMessage("ì´ë™í•  ì¹¸ì„ ì„ íƒí•˜ì„¸ìš”.");
                    this.highlightCells(targets, 'active');
                    this.isWarping = true;
                    this.actionPanel.style.display = 'none'; // Hide panel while picking target
                }

                resolveWarp(targetPos) {
                    this.isWarping = false;
                    this.clearHighlights();

                    this.playerPos = targetPos;
                    this.render();

                    // Show panel again for potentially moving or cancelling
                    if (!this.checkWinCondition()) {
                        this.selectBlock(this.selectedBlockIndex);
                    }
                }

                initiateMove() {
                    const state = this.letterStates[this.selectedBlockIndex];
                    const dec = state.decomposed;

                    // Execute Vowel Move
                    this.performVowelMove(dec.jung);

                    // Mark used
                    state.status = 'used';
                    this.hideActionPanel();
                    this.checkWinCondition();
                }

                performVowelMove(vowel) {
                    let dx = 0, dy = 0;
                    switch (vowel) {
                        case 'ã…': case 'ã…': dx = 1; break;
                        case 'ã…‘': dx = 2; break;
                        case 'ã…“': case 'ã…”': dx = -1; break;
                        case 'ã…•': dx = -2; break;
                        case 'ã…—': case 'ã…š': dy = -1; break;
                        case 'ã…›': dy = -2; break;
                        case 'ã…œ': case 'ã…Ÿ': dy = 1; break;
                        case 'ã… ': dy = 2; break;
                        case 'ã…˜': dx = 1; dy = -1; break;
                        case 'ã…': dx = -1; dy = 1; break;
                        default: break;
                    }

                    if (dx !== 0 || dy !== 0) {
                        this.playerPos.x = Math.max(0, Math.min(this.gridSize - 1, this.playerPos.x + dx));
                        this.playerPos.y = Math.max(0, Math.min(this.gridSize - 1, this.playerPos.y + dy));
                        this.render();
                    }
                }

                checkWinCondition() {
                    // 1. Immediate Win Check
                    if (this.playerPos.x === this.targetPos.x && this.playerPos.y === this.targetPos.y) {
                        this.showMessage("ğŸ‰ ì„±ê³µ! ì ì‹œ í›„ ë‹¤ìŒ ë¬¸ì œë¡œ...");
                        setTimeout(() => {
                            this.isInputLocked = false;
                            this.inputEl.disabled = false;
                            this.startBtn.textContent = "ì‹œì‘";
                            this.startNewLevel();
                        }, 1500);
                        return true;
                    }

                    // 2. Failure Check (All letters used but not at home)
                    const allUsed = this.letterStates.every(s => s.status === 'used');
                    if (allUsed) {
                        this.resetToStartAndRetry();
                        return false;
                    }

                    return false;
                }

                clearHighlights() {
                    const cells = this.gridEl.children;
                    for (let cell of cells) {
                        cell.classList.remove('active');
                    }
                }

                showMessage(msg) {
                    this.messageEl.textContent = msg;
                }

                highlightCells(coords, className) {
                    const cells = this.gridEl.children;
                    coords.forEach(pos => {
                        const idx = pos.y * this.gridSize + pos.x;
                        if (cells[idx]) cells[idx].classList.add(className);
                    });
                }
            }

            window.onload = () => {
                window.game = new GameEngine();
            };
        </script>
</body>

</html>