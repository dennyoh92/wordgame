<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í•œê¸€ ì›Œí”„ (Hangeul Word Warp)</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.7);
            --primary-color: #38bdf8;
            --secondary-color: #818cf8;
            --accent-color: #f472b6;
            --text-color: #f8fafc;
            --grid-size: 5;
            --cell-size: 80px;
        }

        @media (max-width: 480px) {
            :root {
                --cell-size: 65px;
            }

            #game-container {
                padding: 15px;
                border-radius: 16px;
            }

            header h1 {
                font-size: 1.8rem;
            }

            .cell {
                font-size: 1.2rem;
            }

            .input-group {
                flex-direction: column;
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
        }

        #game-container {
            width: 100%;
            max-width: 460px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            text-align: center;
            padding: 24px;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 5px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        header p {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-bottom: 20px;
        }

        #status-panel {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            font-size: 0.9rem;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 8px 15px;
            border-radius: 12px;
        }

        .stat-item .label {
            color: #94a3b8;
            margin-right: 5px;
        }

        #grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 25px;
        }

        #game-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 16px;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: default;
            transition: all 0.3s ease;
        }

        .cell.start {
            border: 2px solid var(--primary-color);
            background: rgba(56, 189, 248, 0.1);
        }

        .cell.target {
            border: 2px solid var(--accent-color);
            background: rgba(244, 114, 182, 0.1);
            animation: pulse 2s infinite;
            font-size: 2rem;
        }

        .cell.player {
            background: var(--primary-color);
            color: var(--bg-color);
            box-shadow: 0 0 20px var(--primary-color);
            transform: scale(1.1);
            z-index: 10;
        }

        .cell.active {
            background: rgba(129, 140, 248, 0.3);
            border-color: var(--secondary-color);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(244, 114, 182, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(244, 114, 182, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(244, 114, 182, 0);
            }
        }

        #control-panel {
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        #word-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 15px;
            color: white;
            font-size: 1rem;
            outline: none;
        }

        #word-input:focus {
            border-color: var(--primary-color);
        }

        #start-btn {
            background: var(--primary-color);
            color: var(--bg-color);
            border: none;
            border-radius: 12px;
            padding: 12px 20px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            min-height: 48px;
        }

        #start-btn:hover {
            background: #7dd3fc;
        }

        .secondary-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 12px 15px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
        }

        .secondary-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .hint-text {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--secondary-color);
            font-weight: bold;
            min-height: 1.2em;
        }

        #active-word-display {
            display: flex;
            justify-content: center;
            gap: 10px;
            min-height: 40px;
            margin-bottom: 10px;
        }

        .letter-block {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.3s;
        }

        .letter-block.current {
            background: var(--secondary-color);
            transform: translateY(-5px);
        }

        #message-display {
            font-size: 0.9rem;
            color: #94a3b8;
            height: 1.5em;
        }

        #guide-panel {
            text-align: left;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 16px;
            font-size: 0.85rem;
        }

        #guide-panel h3 {
            margin-bottom: 10px;
            font-size: 1rem;
        }

        #guide-panel ul {
            list-style: none;
        }

        #guide-panel li {
            margin-bottom: 8px;
            color: #cbd5e1;
        }

        #guide-panel li strong {
            color: var(--primary-color);
        }
    </style>
</head>

<body>
    <div id="game-container">
        <header>
            <h1>í•œê¸€ ì›Œí”„</h1>
            <p>ë‹¨ì–´ì˜ í˜ìœ¼ë¡œ ê³µê°„ì„ ë„ì•½í•˜ì„¸ìš”.</p>
        </header>

        <div id="status-panel">
            <div class="stat-item">
                <span class="label">í˜„ì¬ ìœ„ì¹˜:</span>
                <span id="current-pos">(0, 0)</span>
            </div>
            <div class="stat-item">
                <span class="label">ëª©í‘œ:</span>
                <span id="target-pos">(4, 4)</span>
            </div>
        </div>

        <div id="grid-container">
            <div id="game-grid"></div>
        </div>

        <div id="control-panel">
            <div class="input-group">
                <input type="text" id="word-input" placeholder="ë¬´ê¸°(ë‹¨ì–´)ë¥¼ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
                <button id="start-btn">ì‹œì‘</button>
                <button id="hint-btn" class="secondary-btn">ì •ë‹µ ì˜ˆì‹œ</button>
            </div>
            <div id="active-word-display"></div>
            <div id="message-display">ê²©ì ìœ„ì˜ ììŒì„ ë³´ê³  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</div>
            <div id="hint-display" class="hint-text"></div>
        </div>

        <div id="guide-panel">
            <h3>ì¡°ì‘ ê°€ì´ë“œ</h3>
            <ul>
                <li><strong>ììŒ ì›Œí”„:</strong> ë°›ì¹¨ì´ ìˆëŠ” ê¸€ìì¼ ë•Œ, ì´ˆì„± ìœ„ì¹˜ì—ì„œ ê°™ì€ ììŒì˜ ì¢…ì„± ìœ„ì¹˜ë¡œ(ë˜ëŠ” ë°˜ëŒ€ë¡œ) ì í”„!</li>
                <li><strong>ëª¨ìŒ ì´ë™:</strong> ëª¨ìŒì˜ íš ë°©í–¥ì— ë”°ë¼ 1~2ì¹¸ ë¬¼ë¦¬ì  ì´ë™.</li>
                <li><strong>ì—°ì‡„ ë°˜ì‘:</strong> ì´ë™ í›„ ë‹¤ìŒ ê¸€ìê°€ í™œì„±í™”ë˜ë©´ ì¦‰ì‹œ ë‹¤ìŒ ë‹¨ê³„ë¡œ!</li>
            </ul>
        </div>
    </div>

    <script>
        /**
         * Hangeul Word Warp
         * Core Logic and Engine
         */

        const CONSONANTS = ['ã„±', 'ã„´', 'ã„·', 'ã„¹', 'ã…', 'ã…‚', 'ã……', 'ã…‡', 'ã…ˆ', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
        const CHO = ['ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
        const JUNG = ['ã…', 'ã…', 'ã…‘', 'ã…’', 'ã…“', 'ã…”', 'ã…•', 'ã…–', 'ã…—', 'ã…˜', 'ã…™', 'ã…š', 'ã…›', 'ã…œ', 'ã…', 'ã…', 'ã…Ÿ', 'ã… ', 'ã…¡', 'ã…¢', 'ã…£'];
        const JONG = ['', 'ã„±', 'ã„²', 'ã„³', 'ã„´', 'ã„µ', 'ã„¶', 'ã„·', 'ã„¹', 'ã„º', 'ã„»', 'ã„¼', 'ã„½', 'ã„¾', 'ã„¿', 'ã…€', 'ã…', 'ã…‚', 'ã…„', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];

        const DICTIONARY = [
            'ë¬¼ì‚´', 'ë¶ìª½', 'í•™ê¸°', 'ê³¼í•™', 'ë¬¼í•™', 'ìˆ˜ë°•', 'í•™êµ', 'ë°”ë‹¤', 'ì¶•êµ¬', 'ì‚¬ì', 'ê¸°ì°¨', 'í•˜ëŠ˜', 'í¬ë„', 'ëª¨ì', 'ë‚˜ë¬´', 'ë‚˜ë¹„', 'ìš°ìœ ', 'ì•„ì´', 'ì˜¤ì´',
            'ê°•ë¬¼', 'êµ¬ë¦„', 'ë³„ë¹›', 'ë‹¬ë¹›', 'í–‡ì‚´', 'ë°”ëŒ', 'ì†Œë¦¬', 'ë…¸ë˜', 'ê·¸ë¦¼', 'í¸ì§€', 'ì¹œêµ¬', 'ì‚¬ë‘', 'í–‰ë³µ', 'ë¯¸ì†Œ', 'ê¸°ì¨', 'ìŠ¬í””', 'ìš©ê¸°', 'í¬ë§',
            'ì‚¬ê³¼', 'ì°¸ì™¸', 'ë”¸ê¸°', 'ìˆ˜ë°•', 'í¬ë„', 'ê·¤', 'ì˜¤ë Œì§€', 'ë°”ë‚˜ë‚˜', 'ë§ê³ ', 'ë ˆëª¬', 'ë¼ì„', 'í‚¤ìœ„', 'ìë‘', 'ë³µìˆ­ì•„', 'ì•µë‘', 'ë³´ë¦¬', 'ë²¼',
            'í•œêµ­', 'ì„œìš¸', 'ë¶€ì‚°', 'ëŒ€êµ¬', 'ì¸ì²œ', 'ê´‘ì£¼', 'ëŒ€ì „', 'ìš¸ì‚°', 'ì„¸ì¢…', 'ê²½ê¸°', 'ê°•ì›', 'ì¶©ë¶', 'ì¶©ë‚¨', 'ì „ë¶', 'ì „ë‚¨', 'ê²½ë¶', 'ê²½ë‚¨', 'ì œì£¼'
        ];

        class HangeulParser {
            static decompose(syllable) {
                const code = syllable.charCodeAt(0) - 44032;
                if (code < 0 || code > 11171) return null;

                const jongIdx = code % 28;
                const jungIdx = ((code - jongIdx) / 28) % 21;
                const choIdx = (((code - jongIdx) / 28) - jungIdx) / 21;

                return {
                    cho: CHO[choIdx],
                    jung: JUNG[jungIdx],
                    jong: JONG[jongIdx]
                };
            }
        }

        class GameEngine {
            constructor() {
                this.gridSize = 5;
                this.grid = [];
                this.playerPos = { x: 0, y: 0 };
                this.targetPos = { x: 4, y: 4 };
                this.currentWord = "";
                this.wordIndex = 0;
                this.isMoving = false;

                this.init();
            }

            init() {
                this.generateSolvableLevel();
                this.setupDOM();
                this.render();
            }

            generateSolvableLevel() {
                let attempts = 0;
                let solved = false;

                while (!solved && attempts < 200) {
                    attempts++;
                    this.randomizePoints();
                    this.createGrid();
                    if (this.findSolutions().length > 0) {
                        solved = true;
                    }
                }

                if (!solved) {
                    console.warn("í’€ ìˆ˜ ìˆëŠ” ë ˆë²¨ì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì‚¬ì „ì´ë‚˜ ê²©ì ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.");
                }
            }

            randomizePoints() {
                // Randomize start and target with at least 3 distance (Manhattan)
                do {
                    this.playerPos = {
                        x: Math.floor(Math.random() * this.gridSize),
                        y: Math.floor(Math.random() * this.gridSize)
                    };
                    this.targetPos = {
                        x: Math.floor(Math.random() * this.gridSize),
                        y: Math.floor(Math.random() * this.gridSize)
                    };
                } while (Math.abs(this.playerPos.x - this.targetPos.x) + Math.abs(this.playerPos.y - this.targetPos.y) < 3);
            }

            createGrid() {
                this.grid = [];
                for (let y = 0; y < this.gridSize; y++) {
                    const row = [];
                    for (let x = 0; x < this.gridSize; x++) {
                        // Target cell has no consonant
                        if (x === this.targetPos.x && y === this.targetPos.y) {
                            row.push("");
                        } else {
                            const randomConsonant = CONSONANTS[Math.floor(Math.random() * CONSONANTS.length)];
                            row.push(randomConsonant);
                        }
                    }
                    this.grid.push(row);
                }
            }

            setupDOM() {
                this.gridEl = document.getElementById('game-grid');
                this.inputEl = document.getElementById('word-input');
                this.startBtn = document.getElementById('start-btn');
                this.messageEl = document.getElementById('message-display');
                this.wordDisplayEl = document.getElementById('active-word-display');
                this.posDisplayEl = document.getElementById('current-pos');
                this.targetDisplayEl = document.getElementById('target-pos');
                this.hintBtn = document.getElementById('hint-btn');
                this.hintDisplayEl = document.getElementById('hint-display');

                this.startBtn.onclick = () => this.handleStart();
                this.hintBtn.onclick = () => this.showHint();
                this.inputEl.onkeypress = (e) => {
                    if (e.key === 'Enter') this.handleStart();
                };

                this.targetDisplayEl.textContent = `(${this.targetPos.x}, ${this.targetPos.y})`;

                // Add click listener for cells (for manual targeting if we want to allow it later)
                this.gridEl.onclick = (e) => {
                    const cell = e.target.closest('.cell');
                    if (cell && this.isWaitingForWarp) {
                        const idx = Array.from(this.gridEl.children).indexOf(cell);
                        const x = idx % this.gridSize;
                        const y = Math.floor(idx / this.gridSize);
                        this.resolveWarp({ x, y });
                    }
                };
            }

            render() {
                this.gridEl.innerHTML = '';
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.textContent = this.grid[y][x];

                        if (x === this.playerPos.x && y === this.playerPos.y) {
                            cell.classList.add('player');
                        }
                        if (x === this.targetPos.x && y === this.targetPos.y) {
                            cell.classList.add('target');
                        }

                        this.gridEl.appendChild(cell);
                    }
                }
                this.posDisplayEl.textContent = `(${this.playerPos.x}, ${this.playerPos.y})`;
                this.targetDisplayEl.textContent = `(${this.targetPos.x}, ${this.targetPos.y})`;
            }

            async handleStart() {
                if (this.isMoving) return;
                const word = this.inputEl.value.trim();
                if (!word) {
                    this.showMessage("ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”!");
                    return;
                }

                if (word.length < 2) {
                    this.showMessage("ë‹¨ì–´ëŠ” ìµœì†Œ 2ê¸€ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤!");
                    return;
                }

                this.currentWord = word;
                this.wordIndex = 0;
                this.isMoving = true;
                this.hintDisplayEl.textContent = ""; // Clear hint
                this.renderWordBlocks();

                await this.processWord();
                // Only set isMoving to false if we didn't already succeed and transition
                if (this.playerPos.x !== this.targetPos.x || this.playerPos.y !== this.targetPos.y) {
                    this.isMoving = false;
                }
            }

            startNewLevel() {
                this.inputEl.value = "";
                this.wordDisplayEl.innerHTML = "";
                this.generateSolvableLevel();
                this.render();
                this.showMessage("ê²©ì ìœ„ì˜ ììŒì„ ë³´ê³  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
            }

            showHint() {
                const solutions = this.findSolutions();
                if (solutions.length > 0) {
                    // Show the shortest or first valid solution
                    const best = solutions.sort((a, b) => a.length - b.length)[0];
                    this.hintDisplayEl.textContent = `ì¶”ì²œ ë‹¨ì–´: ${best}`;
                } else {
                    this.hintDisplayEl.textContent = "í˜„ì¬ ìœ„ì¹˜ì—ì„œ ë„ë‹¬ ê°€ëŠ¥í•œ ë‹¨ì–´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.";
                }
            }

            findSolutions() {
                const possible = [];
                for (const word of DICTIONARY) {
                    if (word.length >= 2 && this.simulateWord(word)) {
                        possible.push(word);
                    }
                }
                return possible;
            }

            simulateWord(word) {
                let tempPos = { x: this.playerPos.x, y: this.playerPos.y };

                for (let i = 0; i < word.length; i++) {
                    const char = word[i];
                    const decomposed = HangeulParser.decompose(char);
                    if (!decomposed) return false;

                    const currentConsonant = this.grid[tempPos.y][tempPos.x];
                    const canActivate = (currentConsonant === decomposed.cho || (decomposed.jong && currentConsonant === decomposed.jong));
                    if (!canActivate) return false;

                    // Simulate Warp
                    if (decomposed.jong) {
                        let targetConsonant = "";
                        if (currentConsonant === decomposed.cho) targetConsonant = decomposed.jong;
                        else if (currentConsonant === decomposed.jong) targetConsonant = decomposed.cho;

                        if (targetConsonant) {
                            const potentialTargets = [];
                            for (let y = 0; y < this.gridSize; y++) {
                                for (let x = 0; x < this.gridSize; x++) {
                                    if (this.grid[y][x] === targetConsonant && (x !== tempPos.x || y !== tempPos.y)) {
                                        potentialTargets.push({ x, y });
                                    }
                                }
                            }
                            if (potentialTargets.length > 0) {
                                // In simulation, we need to know if ANY of these paths lead to victory.
                                // For simplicity, let's assume the "best" jump (closest to goal).
                                potentialTargets.sort((a, b) => {
                                    const distA = Math.abs(a.x - this.targetPos.x) + Math.abs(a.y - this.targetPos.y);
                                    const distB = Math.abs(b.x - this.targetPos.x) + Math.abs(b.y - this.targetPos.y);
                                    return distA - distB;
                                });
                                tempPos = { x: potentialTargets[0].x, y: potentialTargets[0].y };
                            }
                        }
                    }

                    // Simulate Vowel Move
                    let dx = 0, dy = 0;
                    const vowel = decomposed.jung;
                    switch (vowel) {
                        case 'ã…': case 'ã…': dx = 1; break;
                        case 'ã…‘': dx = 2; break;
                        case 'ã…“': case 'ã…”': dx = -1; break;
                        case 'ã…•': dx = -2; break;
                        case 'ã…—': case 'ã…š': dy = -1; break;
                        case 'ã…›': dy = -2; break;
                        case 'ã…œ': case 'ã…Ÿ': dy = 1; break;
                        case 'ã… ': dy = 2; break;
                        case 'ã…˜': dx = 1; dy = -1; break;
                        case 'ã…': dx = -1; dy = 1; break;
                    }
                    tempPos.x = Math.max(0, Math.min(this.gridSize - 1, tempPos.x + dx));
                    tempPos.y = Math.max(0, Math.min(this.gridSize - 1, tempPos.y + dy));

                    if (tempPos.x === this.targetPos.x && tempPos.y === this.targetPos.y) {
                        return true;
                    }
                }
                return false;
            }

            renderWordBlocks() {
                this.wordDisplayEl.innerHTML = '';
                for (let i = 0; i < this.currentWord.length; i++) {
                    const block = document.createElement('div');
                    block.className = 'letter-block';
                    block.textContent = this.currentWord[i];
                    this.wordDisplayEl.appendChild(block);
                }
            }

            showMessage(msg) {
                this.messageEl.textContent = msg;
            }

            async processWord() {
                while (this.wordIndex < this.currentWord.length) {
                    const char = this.currentWord[this.wordIndex];
                    const decomposed = HangeulParser.decompose(char);

                    if (!decomposed) {
                        this.showMessage(`'${char}'ì€ í•œê¸€ì´ ì•„ë‹™ë‹ˆë‹¤.`);
                        break;
                    }

                    // Update UI for current block
                    const blocks = this.wordDisplayEl.children;
                    for (let i = 0; i < blocks.length; i++) {
                        blocks[i].classList.toggle('current', i === this.wordIndex);
                    }

                    this.showMessage(`í˜„ì¬ ê¸€ì: ${char}`);

                    // Check Activation
                    const currentCellConsonant = this.grid[this.playerPos.y][this.playerPos.x];
                    // Rule: Current consonant must match either Cho or Jong of the current letter
                    const canActivate = (currentCellConsonant === decomposed.cho || (decomposed.jong && currentCellConsonant === decomposed.jong));

                    if (!canActivate) {
                        this.showMessage(`í™œì„±í™” ì‹¤íŒ¨: '${char}'ì˜ ììŒê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`);
                        break;
                    }

                    // Step 1: Consonant Warp (Available if letter has Jong)
                    if (decomposed.jong) {
                        await this.performWarp(decomposed);
                    }

                    // Step 2: Vowel Move
                    await this.performVowelMove(decomposed.jung);

                    this.render();

                    if (this.playerPos.x === this.targetPos.x && this.playerPos.y === this.targetPos.y) {
                        this.showMessage("ğŸ‰ ì„±ê³µ! ë‹¤ìŒ ë¬¸ì œë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤...");
                        this.isMoving = false;

                        // Wait and start new level
                        await new Promise(r => setTimeout(r, 1500));
                        this.startNewLevel();
                        return;
                    }

                    // Move to next letter in word
                    this.wordIndex++;
                    await new Promise(r => setTimeout(r, 600));
                }

                if (this.playerPos.x !== this.targetPos.x || this.playerPos.y !== this.targetPos.y) {
                    this.showMessage("ê²Œì„ ì¢…ë£Œ. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.");
                }
            }

            async performWarp(decomposed) {
                const currentConsonant = this.grid[this.playerPos.y][this.playerPos.x];
                let targetConsonant = "";

                // Determine the "other" consonant to jump TO
                if (currentConsonant === decomposed.cho && decomposed.jong) {
                    targetConsonant = decomposed.jong;
                } else if (currentConsonant === decomposed.jong) {
                    targetConsonant = decomposed.cho;
                }

                if (!targetConsonant) return;

                // Find potential targets
                const potentialTargets = [];
                for (let y = 0; y < this.gridSize; y++) {
                    for (let x = 0; x < this.gridSize; x++) {
                        if (this.grid[y][x] === targetConsonant && (x !== this.playerPos.x || y !== this.playerPos.y)) {
                            potentialTargets.push({ x, y });
                        }
                    }
                }

                if (potentialTargets.length > 0) {
                    this.showMessage(`'${targetConsonant}' ììŒ ì›Œí”„ ì¤‘...`);

                    // Visualize potential targets
                    this.highlightCells(potentialTargets, 'active');

                    // Auto-pick the best one for now (closest to goal)
                    // In a better version, we'd wait for user input here.
                    potentialTargets.sort((a, b) => {
                        const distA = Math.abs(a.x - this.targetPos.x) + Math.abs(a.y - this.targetPos.y);
                        const distB = Math.abs(b.x - this.targetPos.x) + Math.abs(b.y - this.targetPos.y);
                        return distA - distB;
                    });

                    await new Promise(r => setTimeout(r, 600));
                    this.playerPos = potentialTargets[0];
                    this.render();
                    await new Promise(r => setTimeout(r, 400));
                }
            }

            highlightCells(coords, className) {
                const cells = this.gridEl.children;
                coords.forEach(pos => {
                    const idx = pos.y * this.gridSize + pos.x;
                    if (cells[idx]) cells[idx].classList.add(className);
                });
            }

            async performVowelMove(vowel) {
                let dx = 0, dy = 0;

                switch (vowel) {
                    case 'ã…': case 'ã…': dx = 1; break;
                    case 'ã…‘': dx = 2; break;
                    case 'ã…“': case 'ã…”': dx = -1; break;
                    case 'ã…•': dx = -2; break;
                    case 'ã…—': case 'ã…š': dy = -1; break;
                    case 'ã…›': dy = -2; break;
                    case 'ã…œ': case 'ã…Ÿ': dy = 1; break;
                    case 'ã… ': dy = 2; break;
                    case 'ã…˜': dx = 1; dy = -1; break;
                    case 'ã…': dx = -1; dy = 1; break;
                    default: break; // ã…¡, ã…£ ë“±ì€ ì´ë™ ì•ˆí•¨
                }

                if (dx !== 0 || dy !== 0) {
                    this.showMessage(`ëª¨ìŒ ì´ë™: ${vowel}`);
                    this.playerPos.x = Math.max(0, Math.min(this.gridSize - 1, this.playerPos.x + dx));
                    this.playerPos.y = Math.max(0, Math.min(this.gridSize - 1, this.playerPos.y + dy));
                    this.render();
                    await new Promise(r => setTimeout(r, 400));
                }
            }
        }

        window.onload = () => {
            window.game = new GameEngine();
        };
    </script>
</body>

</html>