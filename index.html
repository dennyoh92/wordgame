<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>숨바꼭질 (Hide and Seek)</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.7);
            --primary-color: #38bdf8;
            --secondary-color: #818cf8;
            --accent-color: #f472b6;
            --text-color: #f8fafc;
            --grid-size: 5;
            --cell-size: clamp(50px, 15vw, 80px);
        }

        @media (max-width: 480px) {
            #game-container {
                padding: 15px;
                border-radius: 16px;
            }

            header h1 {
                font-size: 2rem;
            }

            .cell {
                font-size: 1.2rem;
            }

            .input-group {
                flex-direction: column;
                gap: 5px;
            }

            .secondary-btn,
            #start-btn {
                width: 100%;
            }

            #active-word-display {
                gap: 5px;
            }
        }

        @media (max-width: 380px) {
            #game-grid {
                gap: 6px;
                padding: 6px;
            }

            .cell {
                border-radius: 6px;
            }

            .letter-block {
                padding: 4px 8px;
                font-size: 1rem;
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            /* Remove mobile tap highlight */
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100dvh;
            padding: 10px;
            overflow-y: auto;
        }

        #game-container {
            width: 100%;
            max-width: 460px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            text-align: center;
            padding: 24px;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 5px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        header p {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-bottom: 20px;
        }



        #grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 25px;
            position: relative;
        }

        #game-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 16px;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: default;
            transition: all 0.3s ease;
        }

        .cell.start {
            border: 2px solid var(--primary-color);
            background: rgba(56, 189, 248, 0.1);
        }

        .cell.target {
            border: 2px solid var(--accent-color);
            background: rgba(244, 114, 182, 0.1);
            animation: pulse 2s infinite;
            font-size: 2rem;
        }

        .cell.player {
            background: var(--primary-color);
            color: var(--bg-color);
            box-shadow: 0 0 20px var(--primary-color);
            transform: scale(1.1);
            z-index: 10;
        }

        .cell.active {
            background: rgba(129, 140, 248, 0.3);
            border-color: var(--secondary-color);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(244, 114, 182, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(244, 114, 182, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(244, 114, 182, 0);
            }
        }

        #control-panel {
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        #word-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 15px;
            color: white;
            font-size: 1rem;
            outline: none;
        }

        #word-input:focus {
            border-color: var(--primary-color);
        }

        #start-btn {
            background: var(--primary-color);
            color: var(--bg-color);
            border: none;
            border-radius: 12px;
            padding: 8px 15px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
        }

        #start-btn:hover {
            background: #7dd3fc;
        }

        .secondary-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 8px 15px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
        }

        .secondary-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .hint-text {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--secondary-color);
            font-weight: bold;
            min-height: 1.2em;
        }

        #active-word-display {
            display: flex;
            justify-content: center;
            gap: 10px;
            min-height: 40px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            /* Wrap for mobile */
        }

        .letter-block {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.3s;
        }

        .letter-block.current {
            background: var(--secondary-color);
            transform: translateY(-5px);
        }

        #message-display {
            font-size: 0.9rem;
            color: #94a3b8;
            min-height: 1.5em;
            margin-bottom: 10px;
        }

        #guide-panel {
            text-align: left;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 16px;
            font-size: 0.85rem;
        }

        #guide-panel h3 {
            margin-bottom: 10px;
            font-size: 1rem;
        }

        #guide-panel ul {
            list-style: none;
        }

        #guide-panel li {
            margin-bottom: 8px;
            color: #cbd5e1;
        }

        #action-panel {
            background: rgba(15, 23, 42, 0.5);
            padding: 15px;
            border-radius: 16px;
            border: 1px solid var(--primary-color);
            display: none;
            flex-direction: column;
            gap: 10px;
            margin: 15px auto;
            width: fit-content;
            min-width: 250px;
        }

        #action-panel h3 {
            margin-bottom: 10px;
            color: var(--text-color);
            font-size: 1.2rem;
        }

        .action-btn {
            background: var(--card-bg);
            border: 1px solid var(--secondary-color);
            color: white;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        .action-btn:hover:not(:disabled) {
            background: var(--secondary-color);
            color: var(--bg-color);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #475569;
        }

        .letter-block {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.3s;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .letter-block:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .letter-block.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
        }

        .letter-block.warped {
            background: rgba(129, 140, 248, 0.4);
            border-color: var(--secondary-color);
            color: white;
            cursor: pointer;
        }

        .letter-block.used {
            background: #475569;
            color: #94a3b8;
            opacity: 0.7;
            text-decoration: line-through;
            cursor: default;
        }

        #guide-panel li strong {
            color: var(--primary-color);
        }
    </style>
</head>

<body>
    <div id="game-container">
        <header>
            <h1>숨바꼭질</h1>
            <p>단어의 힘으로 공간을 도약하세요.</p>
        </header>



        <div id="grid-container">
            <script src="dictionary.js"></script>
            <div id="game-grid"></div>
            <div id="constraint-badge"
                style="display: none; position: absolute; top: 10px; right: 10px; background: #ef4444; color: white; padding: 4px 10px; border-radius: 20px; font-size: 0.75rem; font-weight: bold; z-index: 10; box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);">
                3글자 제한</div>
        </div>

        <div id="control-panel">
            <div class="input-group">
                <input type="text" id="word-input" placeholder="단어를 입력하세요" maxlength="10">
                <button id="start-btn">게임<br>시작</button>
                <button id="hint-btn" class="secondary-btn">정답<br>보기</button>
            </div>

            <div id="action-panel">
                <h3 id="action-title" style="margin-bottom: 8px; color: var(--text-color); font-size: 1.1rem;">선택: ?
                </h3>
                <div style="display: flex; gap: 8px; justify-content: center; width: 100%;">
                    <button id="btn-warp" class="action-btn" style="flex: 1; padding: 10px 5px; font-size: 0.9rem;">자음
                        워프 (Warp)</button>
                    <button id="btn-move" class="action-btn" style="flex: 1; padding: 10px 5px; font-size: 0.9rem;">모음
                        이동 (Move)</button>
                </div>
            </div>
            <div id="active-word-display"></div>
            <div id="message-display">격자 위의 자음을 보고 단어를 입력하세요.</div>
            <div id="hint-display" class="hint-text"></div>

            <div id="guide-panel">
                <h3>조작 가이드</h3>
                <div
                    style="font-size: 0.8rem; color: var(--secondary-color); margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px;">
                    <strong>자음 워프:</strong> 초성 ↔ 종성 위치를 번갈아 이동 (받침 필수)
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 0.75rem;">
                    <div>ㅏ, ㅐ : 오른쪽 1칸 (→)</div>
                    <div>ㅑ, ㅒ : 오른쪽 2칸 (⇉)</div>
                    <div>ㅓ, ㅔ : 왼쪽 1칸 (←)</div>
                    <div>ㅕ, ㅖ : 왼쪽 2칸 (⇇)</div>
                    <div>ㅗ, ㅚ : 위쪽 1칸 (↑)</div>
                    <div>ㅛ : 위쪽 2칸 (⇈)</div>
                    <div>ㅜ, ㅟ : 아래쪽 1칸 (↓)</div>
                    <div>ㅠ : 아래쪽 2칸 (⇊)</div>
                    <div>ㅘ, ㅙ : 우측 상단 (↗)</div>
                    <div>ㅝ : 좌측 하단 (↙)</div>
                    <div
                        style="grid-column: span 2; text-align: center; margin-top: 3px; color: #94a3b8; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 3px;">
                        ㅡ, ㅣ, ㅢ : 이동하지 않음</div>
                </div>
            </div>
        </div>

        <script>
            /**
             * Hangeul Word Warp
             * Core Logic and Engine
             */

            const CONSONANTS = ['ㄱ', 'ㄴ', 'ㄷ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
            const CHO = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
            const JUNG = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'];
            const JONG = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];

            const DICTIONARY = [
                '물살', '북쪽', '학기', '과학', '물학', '수박', '학교', '바다', '축구', '사자', '기차', '하늘', '포도', '모자', '나무', '나비', '우유', '아이', '오이',
                '강물', '구름', '별빛', '달빛', '햇살', '바람', '소리', '노래', '그림', '편지', '친구', '사랑', '행복', '미소', '기쁨', '슬픔', '용기', '희망',
                '사과', '참외', '딸기', '수박', '포도', '귤', '오렌지', '바나나', '망고', '레몬', '라임', '키위', '자두', '복숭아', '앵두', '보리', '벼',
                '한국', '서울', '부산', '대구', '인천', '광주', '대전', '울산', '세종', '경기', '강원', '충북', '충남', '전북', '전남', '경북', '경남', '제주'
            ];

            class HangeulParser {
                static decompose(syllable) {
                    const code = syllable.charCodeAt(0) - 44032;
                    if (code < 0 || code > 11171) return null;

                    const jongIdx = code % 28;
                    const jungIdx = ((code - jongIdx) / 28) % 21;
                    const choIdx = (((code - jongIdx) / 28) - jungIdx) / 21;

                    return {
                        cho: CHO[choIdx],
                        jung: JUNG[jungIdx],
                        jong: JONG[jongIdx]
                    };
                }
            }

            class GameEngine {
                constructor() {
                    this.gridSize = 5;
                    this.grid = [];
                    this.playerPos = { x: 0, y: 0 };
                    this.targetPos = { x: 4, y: 4 };
                    this.startPos = { x: 0, y: 0 }; // Track start for reset

                    this.currentWord = "";
                    this.letterStates = []; // { char, status: 'unused'|'used', index }
                    this.selectedBlockIndex = -1;
                    this.wordLengthLimit = null; // null or 3

                    this.isInputLocked = false;
                    this.isWarping = false; // Waiting for target click

                    this.externalDictionary = new Set();
                    this.isDictLoaded = false;

                    this.init();
                }

                init() {
                    this.setupDOM();
                    this.loadDictionary();
                    this.generateSolvableLevel();
                    this.render();
                }

                async loadDictionary() {
                    // Try to load from window.hangeulDictionary (loaded via script tag)
                    if (window.hangeulDictionary && Array.isArray(window.hangeulDictionary)) {
                        this.externalDictionary = new Set(window.hangeulDictionary);
                        this.isDictLoaded = true;
                        console.log(`Loaded ${window.hangeulDictionary.length} words from dictionary.js`);
                        this.showMessage("사전 데이터 로드 완료!");
                        document.getElementById('start-btn').innerHTML = "게임<br>시작";
                        document.getElementById('start-btn').disabled = false;
                    } else {
                        // Fallback: Try fetch for json (in case running on server)
                        try {
                            const response = await fetch('dictionary.json');
                            if (!response.ok) throw new Error("Dictionary not found");
                            const words = await response.json();
                            this.externalDictionary = new Set(words);
                            this.isDictLoaded = true;
                            this.showMessage("사전 데이터 로드 완료!");
                            document.getElementById('start-btn').innerHTML = "게임<br>시작";
                            document.getElementById('start-btn').disabled = false;
                        } catch (e) {
                            console.warn("Failed to load dictionary.", e);
                            this.showMessage("사전 로드 실패. 올바른 단어 확인이 불가능합니다.");
                            // Allow start anyway? Or block?
                            // Let's allow start but keep isDictLoaded false so we know checking is disabled?
                            // User wants VALIDATION. If missing, we should probably warn strongly.
                            document.getElementById('start-btn').innerHTML = "사전 없이<br>시작";
                            document.getElementById('start-btn').disabled = false;
                        }
                    }
                }

                isValidWord(word) {
                    // 1. If external dict loaded, check it
                    if (this.isDictLoaded) {
                        return this.externalDictionary.has(word);
                    }
                    // 2. Fallback to basic dictionary (optional, or just allow all if dict missing?)
                    // For now, let's just warn if dict missing but still use internal for recommendation
                    // If user specifically requested strict validation, we might want to be strict.
                    // But without the file, game becomes unplayable if strict.
                    // So: If dict NOT loaded, allow any >=2 inputs? Or basic dict?
                    // User requirement: "input actual words".
                    // If dict is missing, we can't truly validate.
                    // Let's fallback to internal DICTIONARY for minimal check, or allow all with warning.
                    return true;
                }

                generateSolvableLevel() {
                    const startTime = performance.now();
                    let attempts = 0;
                    let bestLevel = null;

                    // 50% chance to set 3-letter limit
                    this.wordLengthLimit = Math.random() < 0.5 ? 3 : null;

                    while (attempts < 500) {
                        attempts++;
                        const word = DICTIONARY[Math.floor(Math.random() * DICTIONARY.length)];
                        if (this.wordLengthLimit && word.length > this.wordLengthLimit) continue;

                        const tempGrid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(""));
                        let currentPos = {
                            x: Math.floor(Math.random() * this.gridSize),
                            y: Math.floor(Math.random() * this.gridSize)
                        };
                        const playerStart = { ...currentPos };
                        const pathPositions = [];
                        let possible = true;

                        for (let i = 0; i < word.length; i++) {
                            const char = word[i];
                            const decomposed = HangeulParser.decompose(char);
                            if (!decomposed) { possible = false; break; }

                            // 1. Current position must accommodate the start of the syllable (cho or jong)
                            // If we just entered this step from a vowel move, we need to place the starting consonant.
                            // If it's a 'jong' word, we can start with 'cho'.
                            const startConsonant = decomposed.cho;
                            if (tempGrid[currentPos.y][currentPos.x] !== "" && tempGrid[currentPos.y][currentPos.x] !== startConsonant) {
                                possible = false; break;
                            }
                            tempGrid[currentPos.y][currentPos.x] = startConsonant;
                            pathPositions.push({ ...currentPos });

                            // 2. Handle Warp (if jong exists)
                            if (decomposed.jong) {
                                // We need to jump to a cell with decomposed.jong
                                // Pick a random cell that isn't the current one
                                let jumpX, jumpY;
                                let jumpAttempts = 0;
                                do {
                                    jumpX = Math.floor(Math.random() * this.gridSize);
                                    jumpY = Math.floor(Math.random() * this.gridSize);
                                    jumpAttempts++;
                                } while ((jumpX === currentPos.x && jumpY === currentPos.y) && jumpAttempts < 20);

                                if (tempGrid[jumpY][jumpX] !== "" && tempGrid[jumpY][jumpX] !== decomposed.jong) {
                                    possible = false; break;
                                }
                                tempGrid[jumpY][jumpX] = decomposed.jong;
                                currentPos = { x: jumpX, y: jumpY };
                                pathPositions.push({ ...currentPos });
                            }

                            // 3. Handle Vowel Move
                            let dx = 0, dy = 0;
                            const vowel = decomposed.jung;
                            switch (vowel) {
                                case 'ㅏ': case 'ㅐ': dx = 1; break;
                                case 'ㅑ': case 'ㅒ': dx = 2; break;
                                case 'ㅓ': case 'ㅔ': dx = -1; break;
                                case 'ㅕ': case 'ㅖ': dx = -2; break;
                                case 'ㅗ': case 'ㅚ': dy = -1; break;
                                case 'ㅛ': dy = -2; break;
                                case 'ㅜ': case 'ㅟ': dy = 1; break;
                                case 'ㅠ': dy = 2; break;
                                case 'ㅘ': case 'ㅙ': dx = 1; dy = -1; break;
                                case 'ㅝ': dx = -1; dy = 1; break;
                            }
                            const nextX = currentPos.x + dx;
                            const nextY = currentPos.y + dy;

                            if (nextX < 0 || nextX >= this.gridSize || nextY < 0 || nextY >= this.gridSize) {
                                possible = false; break;
                            }

                            currentPos = { x: nextX, y: nextY };
                            // Note: the next consonant will be placed in the next iteration's step 1.
                        }

                        if (possible) {
                            // Ensure the final target position is reachable and set as target
                            const target = { ...currentPos };
                            // Optional: Ensure distance between start and target
                            const manhattan = Math.abs(playerStart.x - target.x) + Math.abs(playerStart.y - target.y);
                            if (manhattan >= 2) {
                                // Success! Fill the rest of the grid
                                for (let y = 0; y < this.gridSize; y++) {
                                    for (let x = 0; x < this.gridSize; x++) {
                                        if (tempGrid[y][x] === "") {
                                            tempGrid[y][x] = CONSONANTS[Math.floor(Math.random() * CONSONANTS.length)];
                                        }
                                    }
                                }
                                // Ensure target cell is empty of consonants as per game logic?
                                // Actually, in construction, the target cell is where we land AFTER the last vowel move.
                                // The player wins if they are ON targetPos.

                                bestLevel = {
                                    grid: tempGrid,
                                    playerPos: playerStart,
                                    targetPos: target,
                                    path: pathPositions,
                                    limit: this.wordLengthLimit
                                };
                                break;
                            }
                        }
                    }

                    if (bestLevel) {
                        this.grid = bestLevel.grid;
                        this.playerPos = bestLevel.playerPos;
                        this.targetPos = bestLevel.targetPos;
                        this.wordLengthLimit = bestLevel.limit;
                        // No need to prune if we constructed it correctly, but we can if we want "cleanliness"
                        // this.pruneGrid(bestLevel.path); 

                        if (this.wordLengthLimit) {
                            this.showMessage(`3글자 제한 라운드!`);
                        }
                        const endTime = performance.now();
                        console.log(`Level generated in ${attempts} attempts (${(endTime - startTime).toFixed(2)}ms)`);
                    } else {
                        // Truly extreme case, fallback to random and hope for the best
                        this.randomizePoints();
                        this.createGrid();
                        console.warn("Construction failed, fallback to random.");
                    }
                }

                calculatePathPenalty(path) {
                    if (!path) return Infinity;
                    let penalty = 0;
                    path.forEach(pos => {
                        const dist = Math.abs(pos.x - this.targetPos.x) + Math.abs(pos.y - this.targetPos.y);
                        if (dist === 1) penalty += 10; // High penalty for using cell adjacent to target
                    });
                    return penalty;
                }

                pruneGrid(path) {
                    if (!path) return;

                    const used = new Set(path.map(p => `${p.x},${p.y}`));

                    // 1. Force remove all target adjacents if they are NOT in path
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (Math.abs(dx) + Math.abs(dy) !== 1) continue; // Only orthogonal
                            const nx = this.targetPos.x + dx;
                            const ny = this.targetPos.y + dy;
                            if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {
                                if (!used.has(`${nx},${ny}`)) {
                                    this.grid[ny][nx] = "";
                                }
                            }
                        }
                    }

                    // 2. Continue pruning other cells, prioritizing those farthest from the target
                    const candidates = [];
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            if (x === this.targetPos.x && y === this.targetPos.y) continue;
                            if (this.grid[y][x] !== "" && !used.has(`${x},${y}`)) {
                                candidates.push({ x, y });
                            }
                        }
                    }

                    // Sort by distance from targetPos (farther first)
                    candidates.sort((a, b) => {
                        const distA = Math.abs(a.x - this.targetPos.x) + Math.abs(a.y - this.targetPos.y);
                        const distB = Math.abs(b.x - this.targetPos.x) + Math.abs(b.y - this.targetPos.y);
                        return distB - distA; // Descending distance
                    });

                    // Aim for about 50-60% empty grid total? Or just keep removing up to a limit
                    const alreadyRemoved = this.grid.flat().filter(c => c === "").length - 1; // -1 for target
                    const maxToRemove = 15 - alreadyRemoved;

                    if (maxToRemove > 0) {
                        const extraRemove = candidates.slice(0, maxToRemove);
                        extraRemove.forEach(pos => {
                            this.grid[pos.y][pos.x] = "";
                        });
                    }
                }

                randomizePoints() {
                    // Randomize start and target with at least 3 distance (Manhattan)
                    do {
                        this.playerPos = {
                            x: Math.floor(Math.random() * this.gridSize),
                            y: Math.floor(Math.random() * this.gridSize)
                        };
                        this.targetPos = {
                            x: Math.floor(Math.random() * this.gridSize),
                            y: Math.floor(Math.random() * this.gridSize)
                        };
                    } while (Math.abs(this.playerPos.x - this.targetPos.x) + Math.abs(this.playerPos.y - this.targetPos.y) < 3);
                }

                createGrid() {
                    this.grid = [];
                    for (let y = 0; y < this.gridSize; y++) {
                        const row = [];
                        for (let x = 0; x < this.gridSize; x++) {
                            // Target cell has no consonant
                            if (x === this.targetPos.x && y === this.targetPos.y) {
                                row.push("");
                            } else {
                                const randomConsonant = CONSONANTS[Math.floor(Math.random() * CONSONANTS.length)];
                                row.push(randomConsonant);
                            }
                        }
                        this.grid.push(row);
                    }
                }

                setupDOM() {
                    this.gridEl = document.getElementById('game-grid');
                    this.inputEl = document.getElementById('word-input');
                    this.startBtn = document.getElementById('start-btn');
                    this.messageEl = document.getElementById('message-display');
                    this.wordDisplayEl = document.getElementById('active-word-display');

                    this.hintBtn = document.getElementById('hint-btn');
                    this.hintDisplayEl = document.getElementById('hint-display');

                    // Action Panel
                    this.actionPanel = document.getElementById('action-panel');
                    this.actionTitle = document.getElementById('action-title');
                    this.btnWarp = document.getElementById('btn-warp');
                    this.btnMove = document.getElementById('btn-move');
                    this.constraintBadge = document.getElementById('constraint-badge');

                    this.startBtn.onclick = () => this.handleStart();
                    this.hintBtn.onclick = () => this.showHint();
                    this.inputEl.onkeypress = (e) => {
                        if (e.key === 'Enter') this.handleStart();
                    };



                    // Grid Click
                    this.gridEl.onclick = (e) => {
                        const cell = e.target.closest('.cell');
                        if (!cell) return;

                        if (this.isWarping) {
                            const idx = Array.from(this.gridEl.children).indexOf(cell);
                            const x = idx % this.gridSize;
                            const y = Math.floor(idx / this.gridSize);

                            // Check if valid target
                            if (cell.classList.contains('active')) {
                                this.resolveWarp({ x, y });
                            }
                        }
                    };

                    // Action Buttons
                    this.btnWarp.onclick = () => this.initiateWarp();
                    this.btnMove.onclick = () => this.initiateMove();
                }

                render() {
                    this.gridEl.innerHTML = '';
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            cell.textContent = this.grid[y][x];

                            if (x === this.playerPos.x && y === this.playerPos.y) {
                                cell.classList.add('player');
                            }
                            if (x === this.targetPos.x && y === this.targetPos.y) {
                                cell.classList.add('target');
                            }
                            // Only show start label if it's the very first render or we still care about starting pos
                            // Let's use a one-time class if needed, but for now just player pos

                            this.gridEl.appendChild(cell);
                        }
                    }

                }

                async handleStart() {
                    if (this.isInputLocked && this.letterStates.length > 0) return;

                    const word = this.inputEl.value.trim();
                    if (!word) {
                        this.showMessage("단어를 입력하세요!");
                        return;
                    }

                    if (this.wordLengthLimit && word.length !== this.wordLengthLimit) {
                        this.showMessage(`${this.wordLengthLimit}글자 단어만 가능합니다!`);
                        return;
                    }

                    if (word.length < 2) { // This check is still relevant if wordLengthLimit is null
                        this.showMessage("단어는 최소 2글자 이상이어야 합니다!");
                        return;
                    }

                    // Validate Word
                    if (this.isDictLoaded && !this.isValidWord(word)) {
                        this.showMessage(`'${word}'은(는) 사전에 없는 단어입니다.`);
                        return;
                    }

                    this.startPos = { ...this.playerPos };
                    this.currentWord = word;

                    // Initialize Letter States
                    this.letterStates = Array.from(word).map((char, index) => ({
                        char,
                        index,
                        status: 'unused', // unused, used
                        decomposed: HangeulParser.decompose(char)
                    }));

                    this.isInputLocked = true;
                    this.inputEl.disabled = true;
                    this.startBtn.innerHTML = "다시<br>하기";
                    this.startBtn.onclick = () => this.resetGame();

                    this.renderWordBlocks();
                    this.showMessage("격자 위의 자음과 일치하는 글자를 클릭하세요.");
                    this.isWarping = false;
                    this.hideActionPanel();
                }

                resetGame() {
                    this.isInputLocked = false;
                    this.inputEl.disabled = false;
                    this.startBtn.innerHTML = "게임<br>시작";
                    this.startBtn.onclick = () => this.handleStart();
                    this.letterStates = [];
                    this.resetToStartPos();
                    this.renderWordBlocks();
                    this.hideActionPanel();
                    this.clearHighlights();
                    this.showMessage("격자 위의 자음을 보고 단어를 입력하세요.");
                }

                resetToStartPos() {
                    this.playerPos = { ...this.startPos };
                    this.render();
                }

                resetToStartAndRetry() {
                    this.showMessage("조건 불일치! 처음 위치로 돌아갑니다.");
                    this.resetToStartPos();
                    // Reset states
                    this.letterStates.forEach(s => s.status = 'unused');
                    this.renderWordBlocks();
                    this.hideActionPanel();
                    this.clearHighlights();
                    this.isWarping = false;
                }

                startNewLevel() {
                    this.initGame();
                }

                initGame() {
                    this.inputEl.value = "";
                    this.wordDisplayEl.innerHTML = "";
                    this.generateSolvableLevel();
                    this.startPos = { ...this.playerPos };
                    this.render();

                    if (this.wordLengthLimit) {
                        this.constraintBadge.style.display = 'block';
                        this.showMessage(`${this.wordLengthLimit}글자 단어로 목표에 도달하세요!`);
                    } else {
                        this.constraintBadge.style.display = 'none';
                        this.showMessage("격자 위의 자음을 보고 단어를 입력하세요.");
                    }
                }

                showHint() {
                    const solutions = this.findSolutions();
                    if (solutions.length > 0) {
                        // Show the shortest or first valid solution
                        const best = solutions.sort((a, b) => a.length - b.length)[0];
                        this.hintDisplayEl.textContent = `추천 단어: ${best}`;
                    } else {
                        this.hintDisplayEl.textContent = "현재 위치에서 도달 가능한 단어를 찾지 못했습니다.";
                    }
                }

                findSolutions(dictSource = null) {
                    const results = [];
                    // Use provided dictSource OR the best available dictionary
                    const dict = dictSource || (this.isDictLoaded ? Array.from(this.externalDictionary) : DICTIONARY);

                    for (const word of dict) {
                        if (this.wordLengthLimit && word.length !== this.wordLengthLimit) continue;
                        if (word.length >= 2 && this.simulateWord(word)) { // Keep word.length >= 2
                            results.push(word);
                        }
                    }
                    return results;
                }

                simulateWord(word) {
                    let tempPos = { x: this.playerPos.x, y: this.playerPos.y };
                    const path = []; // Track used coordinates

                    for (let i = 0; i < word.length; i++) {
                        const char = word[i];
                        const decomposed = HangeulParser.decompose(char);
                        if (!decomposed) return null;

                        // Current cell used
                        path.push({ x: tempPos.x, y: tempPos.y });

                        const currentConsonant = this.grid[tempPos.y][tempPos.x];
                        const canActivate = (currentConsonant === decomposed.cho || (decomposed.jong && currentConsonant === decomposed.jong));
                        if (!canActivate) return null;

                        // Simulate Warp
                        if (decomposed.jong) {
                            let targetConsonant = "";
                            if (currentConsonant === decomposed.cho) targetConsonant = decomposed.jong;
                            else if (currentConsonant === decomposed.jong) targetConsonant = decomposed.cho;

                            if (targetConsonant) {
                                const potentialTargets = [];
                                for (let y = 0; y < this.gridSize; y++) {
                                    for (let x = 0; x < this.gridSize; x++) {
                                        if (this.grid[y][x] === targetConsonant && (x !== tempPos.x || y !== tempPos.y)) {
                                            potentialTargets.push({ x, y });
                                        }
                                    }
                                }
                                if (potentialTargets.length > 0) {
                                    // In simulation, we need to know if ANY of these paths lead to victory.
                                    // For simplicity, let's assume the "best" jump (closest to goal).
                                    potentialTargets.sort((a, b) => {
                                        const distA = Math.abs(a.x - this.targetPos.x) + Math.abs(a.y - this.targetPos.y);
                                        const distB = Math.abs(b.x - this.targetPos.x) + Math.abs(b.y - this.targetPos.y);
                                        return distA - distB;
                                    });
                                    tempPos = { x: potentialTargets[0].x, y: potentialTargets[0].y };
                                    // Warp target used
                                    path.push({ x: tempPos.x, y: tempPos.y });
                                }
                            }
                        }

                        // Simulate Vowel Move
                        let dx = 0, dy = 0;
                        const vowel = decomposed.jung;
                        switch (vowel) {
                            case 'ㅏ': case 'ㅐ': dx = 1; break;
                            case 'ㅑ': case 'ㅒ': dx = 2; break;
                            case 'ㅓ': case 'ㅔ': dx = -1; break;
                            case 'ㅕ': case 'ㅖ': dx = -2; break;
                            case 'ㅗ': case 'ㅚ': dy = -1; break;
                            case 'ㅛ': dy = -2; break;
                            case 'ㅜ': case 'ㅟ': dy = 1; break;
                            case 'ㅠ': dy = 2; break;
                            case 'ㅘ': case 'ㅙ': dx = 1; dy = -1; break;
                            case 'ㅝ': dx = -1; dy = 1; break;
                        }
                        tempPos.x = Math.max(0, Math.min(this.gridSize - 1, tempPos.x + dx));
                        tempPos.y = Math.max(0, Math.min(this.gridSize - 1, tempPos.y + dy));

                        if (tempPos.x === this.targetPos.x && tempPos.y === this.targetPos.y) {
                            return path;
                        }
                    }
                    return null;
                }

                renderWordBlocks() {
                    this.wordDisplayEl.innerHTML = '';
                    this.letterStates.forEach(state => {
                        const block = document.createElement('div');
                        block.className = `letter-block ${state.status}`;
                        if (this.selectedBlockIndex === state.index) block.classList.add('selected');
                        block.textContent = state.char;

                        block.onclick = () => {
                            if (state.status === 'used') return;
                            this.selectBlock(state.index);
                        };

                        this.wordDisplayEl.appendChild(block);
                    });
                }

                selectBlock(index) {
                    if (this.isWarping) return; // Busy

                    this.selectedBlockIndex = index;
                    this.renderWordBlocks();

                    const state = this.letterStates[index];
                    const dec = state.decomposed;

                    if (!dec) {
                        this.showMessage("유효하지 않은 글자입니다.");
                        return;
                    }

                    this.actionTitle.textContent = `선택: '${state.char}'`;
                    this.actionPanel.style.display = 'flex';

                    // Validate Actions
                    const currentConsonant = this.grid[this.playerPos.y][this.playerPos.x];
                    const canActivate = (currentConsonant === dec.cho || (dec.jong && currentConsonant === dec.jong));

                    if (!canActivate) {
                        this.showMessage("현재 위치의 자음과 일치하지 않습니다!");
                        this.btnWarp.disabled = true;
                        this.btnMove.disabled = true;
                    } else {
                        // If on target but not finished, show warning
                        const allUsed = this.letterStates.every(s => s.status === 'used' || s.status === 'warped');
                        if (this.playerPos.x === this.targetPos.x && this.playerPos.y === this.targetPos.y && !allUsed) {
                            this.showMessage("단어의 모든 블록을 사용해야합니다.");
                        } else {
                            this.showMessage("행동을 선택하세요.");
                        }
                        // Check Warp
                        let canWarp = false;
                        if (dec.jong && state.status !== 'warped') {
                            // Check if target exists
                            let targetConsonant = "";
                            if (currentConsonant === dec.cho) targetConsonant = dec.jong;
                            else if (currentConsonant === dec.jong) targetConsonant = dec.cho;

                            if (targetConsonant) {
                                // Check grid for targets
                                const targets = this.findWarpTargets(targetConsonant);
                                if (targets.length > 0) canWarp = true;
                            }
                        }
                        this.btnWarp.disabled = !canWarp;

                        // Check Move (always possible if activatable?)
                        this.btnMove.disabled = false;
                    }
                }

                hideActionPanel() {
                    this.actionPanel.style.display = 'none';
                    this.selectedBlockIndex = -1;
                    this.renderWordBlocks();
                }

                findWarpTargets(targetConsonant) {
                    const targets = [];
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            if (this.grid[y][x] === targetConsonant && (x !== this.playerPos.x || y !== this.playerPos.y)) {
                                targets.push({ x, y });
                            }
                        }
                    }
                    return targets;
                }

                initiateWarp() {
                    const state = this.letterStates[this.selectedBlockIndex];
                    const dec = state.decomposed;
                    const currentConsonant = this.grid[this.playerPos.y][this.playerPos.x];

                    let targetConsonant = "";
                    if (currentConsonant === dec.cho) targetConsonant = dec.jong;
                    else targetConsonant = dec.cho;

                    const targets = this.findWarpTargets(targetConsonant);
                    if (targets.length === 0) return;

                    this.showMessage("이동할 칸을 선택하세요.");
                    this.highlightCells(targets, 'active');
                    this.isWarping = true;
                    this.actionPanel.style.display = 'none'; // Hide panel while picking target
                }

                resolveWarp(targetPos) {
                    this.isWarping = false;
                    this.clearHighlights();

                    this.playerPos = targetPos;
                    this.render();

                    // Mark as warped - this counts as "used" for win condition but still allow Move
                    const state = this.letterStates[this.selectedBlockIndex];
                    state.status = 'warped';

                    // Show panel again for potentially moving or cancelling
                    if (!this.checkWinCondition()) {
                        this.selectBlock(this.selectedBlockIndex);
                    }
                }

                initiateMove() {
                    const state = this.letterStates[this.selectedBlockIndex];
                    const dec = state.decomposed;

                    // Execute Vowel Move
                    this.performVowelMove(dec.jung);

                    // Mark used
                    state.status = 'used';
                    this.hideActionPanel();
                    this.checkWinCondition();
                }

                performVowelMove(vowel) {
                    let dx = 0, dy = 0;
                    switch (vowel) {
                        case 'ㅏ': case 'ㅐ': dx = 1; break;
                        case 'ㅑ': case 'ㅒ': dx = 2; break;
                        case 'ㅓ': case 'ㅔ': dx = -1; break;
                        case 'ㅕ': case 'ㅖ': dx = -2; break;
                        case 'ㅗ': case 'ㅚ': dy = -1; break;
                        case 'ㅛ': dy = -2; break;
                        case 'ㅜ': case 'ㅟ': dy = 1; break;
                        case 'ㅠ': dy = 2; break;
                        case 'ㅘ': case 'ㅙ': dx = 1; dy = -1; break;
                        case 'ㅝ': dx = -1; dy = 1; break;
                        default: break;
                    }

                    if (dx !== 0 || dy !== 0) {
                        this.playerPos.x = Math.max(0, Math.min(this.gridSize - 1, this.playerPos.x + dx));
                        this.playerPos.y = Math.max(0, Math.min(this.gridSize - 1, this.playerPos.y + dy));
                        this.render();
                    }
                }

                checkWinCondition() {
                    // 1. Immediate Win Check
                    if (this.playerPos.x === this.targetPos.x && this.playerPos.y === this.targetPos.y) {
                        const allUsed = this.letterStates.every(s => s.status === 'used' || s.status === 'warped');
                        if (allUsed) {
                            this.showMessage("🎉 성공! 잠시 후 다음 문제로...");
                            setTimeout(() => {
                                this.isInputLocked = false;
                                this.inputEl.disabled = false;
                                this.startBtn.innerHTML = "게임<br>시작";
                                this.startNewLevel();
                            }, 1500);
                            return true;
                        } else {
                            this.showMessage("단어의 모든 블록을 사용해야합니다.");
                            return false;
                        }
                    }

                    // 2. Failure Check (All letters used but not at home)
                    const allUsed = this.letterStates.every(s => s.status === 'used' || s.status === 'warped');
                    if (allUsed) {
                        this.resetToStartAndRetry();
                        return false;
                    }

                    return false;
                }

                clearHighlights() {
                    const cells = this.gridEl.children;
                    for (let cell of cells) {
                        cell.classList.remove('active');
                    }
                }

                showMessage(msg) {
                    if (this.messageEl) this.messageEl.textContent = msg;
                }

                highlightCells(coords, className) {
                    const cells = this.gridEl.children;
                    coords.forEach(pos => {
                        const idx = pos.y * this.gridSize + pos.x;
                        if (cells[idx]) cells[idx].classList.add(className);
                    });
                }
            }

            window.onload = () => {
                window.game = new GameEngine();
            };
        </script>
</body>

</html>