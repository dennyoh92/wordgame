<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hangeul Path - 자음 퍼즐 게임</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0f172a;
            --accent-primary: #38bdf8;
            --accent-secondary: #818cf8;
            --grid-bg: rgba(30, 41, 59, 0.7);
            --cell-bg: rgba(51, 65, 85, 0.8);
            --text-main: #f8fafc;
            --text-dim: #94a3b8;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
            color: var(--text-main);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #root {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            position: relative;
            z-index: 10;
            background: var(--grid-bg);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 2rem;
            padding: 2.5rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 2rem;
            width: 90%;
            max-width: 600px;
        }

        .header {
            text-align: center;
        }

        .title {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(to right, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 0.9rem;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 0.75rem;
            aspect-ratio: 1 / 1;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }

        .cell {
            background: var(--cell-bg);
            border-radius: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }

        .cell::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 100%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .cell:hover {
            transform: translateY(-4px) scale(1.05);
            border-color: var(--accent-primary);
            box-shadow: 0 10px 15px -3px rgba(56, 189, 248, 0.2);
        }

        .cell:hover::before {
            opacity: 1;
        }

        .cell.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.4);
            transform: scale(1.1);
            z-index: 5;
        }

        .cell.target {
            background: rgba(244, 63, 94, 0.2);
            border: 2px dashed rgba(244, 63, 94, 0.5);
            color: #fb7185;
        }

        .cell.target.active {
            background: #f43f5e;
            color: white;
            border: none;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .input-group {
            position: relative;
            display: flex;
            gap: 0.5rem;
        }

        input {
            flex: 1;
            background: rgba(15, 23, 42, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 1rem 1.5rem;
            color: white;
            font-size: 1.1rem;
            outline: none;
            transition: border-color 0.3s;
        }

        input:focus {
            border-color: var(--accent-primary);
        }

        .btn {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg);
            border: none;
            border-radius: 0.75rem;
            padding: 0 1.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.3);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .rules-hint {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-dim);
            background: rgba(15, 23, 42, 0.3);
            padding: 1rem;
            border-radius: 1rem;
        }

        .rule-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }

        .rule-key {
            color: var(--accent-primary);
            font-weight: bold;
        }

        .path-visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid var(--accent-primary);
            color: white;
            padding: 1rem 2rem;
            border-radius: 1rem;
            backdrop-filter: blur(10px);
            z-index: 100;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, 100%);
                opacity: 0;
            }

            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        @media (max-width: 480px) {
            .game-container {
                padding: 1.5rem;
                width: 95%;
                gap: 1.5rem;
            }

            .title {
                font-size: 1.8rem;
            }

            .grid {
                gap: 0.4rem;
            }

            .cell {
                border-radius: 0.5rem;
                font-size: 1.2rem;
            }

            .rules-hint {
                grid-template-columns: 1fr !important;
                gap: 0.75rem;
                font-size: 0.85rem;
                text-align: center;
            }

            .input-group {
                flex-direction: column;
            }

            .btn {
                padding: 1rem;
            }

            .toast {
                width: 90%;
            }
        }


        .bg-glow {
            position: absolute;
            width: 600px;
            height: 600px;
            background: radial-gradient(circle, rgba(56, 189, 248, 0.15) 0%, transparent 70%);
            top: -300px;
            right: -300px;
            pointer-events: none;
            filter: blur(50px);
        }

        .bg-glow-2 {
            position: absolute;
            width: 500px;
            height: 500px;
            background: radial-gradient(circle, rgba(129, 140, 248, 0.1) 0%, transparent 70%);
            bottom: -250px;
            left: -250px;
            pointer-events: none;
            filter: blur(50px);
        }
    </style>
</head>

<body>
    <div class="bg-glow"></div>
    <div class="bg-glow-2"></div>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const INITIALS = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
        const MEDIALS = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'];
        const FINALS = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];

        const BATCHIM_DECOMPOSE = {
            'ㄳ': ['ㄱ', 'ㅅ'], 'ㄵ': ['ㄴ', 'ㅈ'], 'ㄶ': ['ㄴ', 'ㅎ'], 'ㄺ': ['ㄹ', 'ㄱ'], 'ㄻ': ['ㄹ', 'ㅁ'],
            'ㄼ': ['ㄹ', 'ㅂ'], 'ㄽ': ['ㄹ', 'ㅅ'], 'ㄾ': ['ㄹ', 'ㅌ'], 'ㄿ': ['ㄹ', 'ㅍ'], 'ㅀ': ['ㄹ', 'ㅎ'],
            'ㅄ': ['ㅂ', 'ㅅ'], 'ㄲ': ['ㄱ', 'ㄱ'], 'ㅆ': ['ㅅ', 'ㅅ']
        };

        const VOWEL_RULES = {
            'ㅏ': { dx: 1, dy: 0 }, 'ㅑ': { dx: 2, dy: 0 },
            'ㅐ': { dx: 1, dy: 0 }, 'ㅒ': { dx: 2, dy: 0 },
            'ㅓ': { dx: -1, dy: 0 }, 'ㅕ': { dx: -2, dy: 0 },
            'ㅔ': { dx: -1, dy: 0 }, 'ㅖ': { dx: -2, dy: 0 },
            'ㅗ': { dx: 0, dy: -1 }, 'ㅛ': { dx: 0, dy: -2 },
            'ㅜ': { dx: 0, dy: 1 }, 'ㅠ': { dx: 0, dy: 2 },
            'ㅘ': { dx: 1, dy: -1 }, 'ㅝ': { dx: -1, dy: 1 }
        };

        const decomposeSyllable = (char) => {
            const code = char.charCodeAt(0) - 44032;
            if (code < 0 || code > 11171) {
                if (INITIALS.includes(char)) return { consonants: [{ type: 'initial', char: char }], vowel: null };
                return null;
            }
            const i = Math.floor(code / 588);
            const m = Math.floor((code % 588) / 28);
            const f = code % 28;

            const consonants = [{ type: 'initial', char: INITIALS[i] }];
            const finalChar = FINALS[f];
            if (finalChar) {
                if (BATCHIM_DECOMPOSE[finalChar]) {
                    BATCHIM_DECOMPOSE[finalChar].forEach(c => consonants.push({ type: 'final', char: c }));
                } else {
                    consonants.push({ type: 'final', char: finalChar });
                }
            }
            return { consonants, vowel: MEDIALS[m] };
        };

        const WordPuzzleGame = () => {
            const [grid, setGrid] = useState([]);
            const [currentPos, setCurrentPos] = useState({ x: 0, y: 0 });
            const [targetPos, setTargetPos] = useState({ x: 4, y: 4 });
            const [inputValue, setInputValue] = useState('');
            const [message, setMessage] = useState('한 단어로 목표 지점까지 도달하세요!');
            const [isWon, setIsWon] = useState(false);
            const [solution, setSolution] = useState('');
            const [showSolution, setShowSolution] = useState(false);

            useEffect(() => {
                initGame();
            }, []);

            const initGame = () => {
                const conSet = ['ㄱ', 'ㄴ', 'ㄷ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅅ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
                const words = ["친고죄", "친권자", "친근감", "친동생", "친목계", "친목회", "친밀감", "친부모", "친삼촌", "친손녀", "친손자", "친아들", "친아버지", "친어머니", "친언니", "친오빠", "친일파", "친자식", "친정집", "친할머니", "친형제", "친화력", "친환경", "칠거지악", "칠면조", "칠부바지", "칠장이", "칠전팔기", "칡넝쿨", "칡덩굴", "침대보", "침대칸", "침소봉대", "침엽수", "침엽수림", "침입자", "침전물", "침착성", "침체기", "침팬지", "칫솔질", "카나리아", "카네이션", "카드놀이", "카디건", "카리스마", "카메라", "카메라맨", "카메룬", "카멜레온", "카바레", "카세트", "카센터", "카스텔라", "카오스", "카우보이", "카운슬러", "카운슬링", "카운터", "카지노", "카키색", "카타르", "카탈로그", "카테고리", "카톨릭", "카투사", "카페인", "칵테일", "칸막이", "칼국수", "칼로리", "칼바람", "칼부림", "칼싸움", "칼자루", "칼잡이", "캄보디아", "캐나다", "캐러멜", "캐릭터", "캐미솔", "캐비닛", "캐스터", "캐스팅", "캔버스", "캘린더", "캠퍼스", "캠페인", "캥거루", "커리큘럼", "커미션", "커피숍", "커피콩", "커피포트", "컨디션", "컨소시엄", "컨테이너", "컨트롤", "컴퍼스", "컴퓨터", "컵라면", "케이블", "케이블카", "케이스", "케이에스", "케이크", "켄트지", "호경기", "호기심", "호남아", "호들갑", "호랑나비", "호랑이", "호랑이띠", "호롱불", "호루라기", "호루루기", "호르몬", "호리병", "호박꽃", "호박씨", "호박엿", "호박죽", "호사가", "호사다마", "호소력", "호소문", "호숫가", "호스티스", "호스피스", "호시절", "호시탐탐", "호신술", "호신용", "호언장담", "호연지기", "호의적", "호의호식", "호전적", "호조건", "호주머니", "호칭어", "호프집", "호형호제", "호혜적", "호호백발", "호화판", "호환성", "호흡기", "혹부리", "혹세무민", "혼란기", "혼란상", "혼례복", "혼례식", "혼비백산", "혼삿날", "혼수상태", "혼수품", "혼숫감", "혼연일체", "혼인식", "혼잣말", "혼합물", "혼혈아", "홀소리", "홀아버지", "홀아비", "홀어머니", "홀어미", "홀쭉이", "홈드레스", "홈뱅킹", "홈페이지", "홍길동", "홍길동전", "홍당무", "홍두깨", "홍등가", "홍보물", "홍보전", "가가호호", "가감승제", "가건물", "가겟집", "가격표", "가계부", "가계비", "가계약", "가곡집", "가공법", "가공성", "가공식품", "가공식품", "가공업", "가공인물", "가공적", "가공품", "가구재", "가구점", "가극단", "가급적", "가까이", "가나다순", "가난뱅이", "가는귀", "가능성", "가닥가닥", "가독성", "가동성", "가드레일", "가라오케", "가락국수", "가락엿", "가락지", "가랑비", "가랑이", "가랑잎", "가래떡", "가래질", "가래침", "가려움증", "가로대", "가로등", "가로무늬", "가로세로", "가로수", "가로쓰기", "가로줄", "가로축", "가로획", "가루비누", "가루약", "가르마", "가르침", "가리개", "가리비", "가마니", "가마솥", "가망성", "가매장", "가맹국", "가맹점", "가면극", "가무단", "가물치", "가변성", "가변적", "교역자", "교육가", "교육계", "교육법", "교육부", "교육비", "교육열", "교육용", "교육자", "교육적", "교육청", "교육학", "교자상", "교장실", "교정본", "교정지", "교조적", "교조주의", "교직원", "교직자", "교집합", "교차로", "교차점", "교체기", "교통경찰", "교통난", "교통량", "교통비", "교통사고", "교통수단", "교통순경", "교통정리", "교통지옥", "교통질서", "교통편", "교향곡", "교향악", "교향악단", "교화력", "교회당", "교훈성", "교훈적", "구개음화", "구경거리", "구경꾼", "구공탄", "구관조", "구구단", "구구절절", "구금자", "구급낭", "구급약", "구급차", "구기자", "구김살", "구김새", "구내매점", "구내방송", "구내식당", "구내전화", "구닥다리", "구단주", "구더기", "구덩이", "구도자", "구독료", "구독자", "구두끈", "구두닦이", "구두쇠", "구두약", "구두점", "구두창", "구두코", "구둣발", "구둣방", "구둣솔", "구둣주걱", "구들목", "구들장", "구렁이", "구렁텅이", "구레나룻", "구류형", "구름다리", "구름층", "구름판", "구릉지", "구린내", "구릿빛", "구만리", "구매력", "구매자", "구멍가게", "구명대", "구명보트", "구명정", "구명조끼", "구미호", "구사력", "구사일생", "구상도", "구상력", "구상화", "구석구석", "구석기", "구석기", "구석방", "구석빼기", "구설수", "구성비", "구성원", "구성체", "구세군", "구세대", "구세주", "구속력", "구술시험", "농한기", "높낮이", "높이뛰기", "높임말", "높임법", "뇌사자", "뇌세포", "뇌졸중", "뇌종양", "뇌진탕", "뇌출혈", "누더기", "누런색", "누렁소", "누렁이", "누룽지", "누름적", "누리꾼", "누린내", "누비옷", "누비이불", "누에고치", "누에치기", "누이동생", "누진세", "눈가루", "눈가리개", "눈가림", "눈구덩이", "눈구멍", "눈까풀", "눈깔사탕", "눈꺼풀", "눈꼬리", "눈높이", "눈대중", "눈대중", "눈덩이", "눈동자", "눈두덩", "눈뜬장님", "눈망울", "눈맵시", "눈물바다", "눈물샘", "눈방울", "눈보라", "눈사람", "눈사태", "눈서리", "눈속임", "눈송이", "눈시울", "눈싸움", "눈썰매", "눈썰매장", "눈썰미", "눈썹연필", "눈어림", "눈언저리", "눈엣가시", "눈요기", "눈웃음", "눈인사", "눈자위", "눈짐작", "눈초리", "마담뚜", "마당극", "마당놀이", "마당발", "마당쇠", "마도로스", "마디마디", "마라톤", "마룻바닥", "마룻장", "마른반찬", "마른번개", "마른안주", "마른침", "마른하늘", "마름모", "마름질", "마릿수", "마무리", "마법사", "마분지", "마사지", "마수걸이", "마술사", "마스카라", "마스코트", "마스크", "마약상", "마요네즈", "마우스", "마운드", "마을문고", "마을버스", "마음가짐", "마음고생", "마음보", "마음속", "마음씨", "마이너스", "마이동풍", "마이신", "마이크", "마일리지", "마지막", "마찬가지", "마찰음", "마천루", "마침표", "마카로니", "마케팅", "마파람", "마피아", "마호메트", "마후라", "막걸리", "막국수", "막내동이", "막내둥이", "막내딸", "막내아들", "막노동", "막노동꾼", "막노동자", "막대기", "막도장", "막동이", "막둥이", "막무가내", "막바지"];

                let attempts = 0;
                while (attempts < 200) {
                    attempts++;
                    const targetWord = words[Math.floor(Math.random() * words.length)];
                    const syllables = [];
                    for (const char of targetWord) {
                        const decomposed = decomposeSyllable(char);
                        if (decomposed) syllables.push(decomposed);
                    }

                    const tempGrid = Array(5).fill().map(() => Array(5).fill(null));
                    let tx = Math.floor(Math.random() * 5);
                    let ty = Math.floor(Math.random() * 5);
                    let target = { x: tx, y: ty };
                    let curr = { x: tx, y: ty };
                    let possible = true;

                    // Flatten all consonants from all syllables with syllable index
                    const allNodes = syllables.flatMap((s, sIdx) =>
                        s.consonants.map(c => ({ ...c, vowel: s.vowel, sIdx }))
                    );

                    // Work backwards from the LAST node to the FIRST
                    // Forward Rule:
                    // 1. Intra-Syllable (sIdx match) -> Consonant Ability (Unlimited, Omnidirectional)
                    // 2. Inter-Syllable (sIdx diff) -> Vowel Ability (Limited, Directional)

                    for (let i = allNodes.length - 1; i >= 0; i--) {
                        const node = allNodes[i];

                        // Try to place the current node in the grid
                        if (tempGrid[curr.y][curr.x] !== null && tempGrid[curr.y][curr.x] !== node.char) {
                            possible = false; break;
                        }
                        tempGrid[curr.y][curr.x] = node.char;

                        // Calculate backward move to determine position of PREVIOUS node
                        if (i > 0) {
                            const prevNode = allNodes[i - 1]; // Source of forward move
                            const possiblePrevPositions = [];

                            const isIntraSyllable = (prevNode.sIdx === node.sIdx);

                            if (isIntraSyllable) {
                                // CASE A: Intra-Syllable (Consonant Ability)
                                // Forward: Source -> Target via ANY Direction, Dist 1 to 4
                                // Backward: Target -> Source via ANY Direction, Dist 1 to 4
                                const directions = [
                                    { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
                                    { dx: 1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }, { dx: -1, dy: -1 }
                                ];

                                for (const d of directions) {
                                    for (let k = 1; k <= 4; k++) {
                                        const px = curr.x - (d.dx * k);
                                        const py = curr.y - (d.dy * k);
                                        if (px >= 0 && px < 5 && py >= 0 && py < 5) {
                                            if (tempGrid[py][px] === null || tempGrid[py][px] === prevNode.char) {
                                                possiblePrevPositions.push({ x: px, y: py });
                                            }
                                        }
                                    }
                                }
                            }

                            if (possiblePrevPositions.length === 0) { possible = false; break; }
                            const chosen = possiblePrevPositions[Math.floor(Math.random() * possiblePrevPositions.length)];
                            curr = { x: chosen.x, y: chosen.y }; // Move 'curr' backwards to the previous node's spot
                        }
                    }

                    if (possible) {
                        const start = { x: curr.x, y: curr.y };
                        const dist = Math.abs(start.x - target.x) + Math.abs(start.y - target.y);
                        if (dist >= 4) { // Ensure decent difficulty
                            setGrid(tempGrid);
                            setCurrentPos(start);
                            setTargetPos(target);
                            setSolution(targetWord);
                            setIsWon(false);
                            setShowSolution(false);
                            setMessage('한 단어를 입력해 목표까지 이동하세요!');
                            return;
                        }
                    }
                }
                setMessage('레벨 생성 실패. 다시 시도해주세요.');
            };

            const handleMove = () => {
                if (isWon) return;

                const syllables = [];
                for (const char of inputValue) {
                    const decomposed = decomposeSyllable(char);
                    if (decomposed) syllables.push(decomposed);
                }

                if (syllables.length === 0) {
                    setMessage('올바른 한글 단어를 입력해주세요.');
                    return;
                }

                let tempPos = { ...currentPos };
                let failed = false;

                // Flatten all nodes with syllable index to distinguish move types
                const allNodes = syllables.flatMap((s, sIdx) =>
                    s.consonants.map(c => ({ ...c, vowel: s.vowel, sIdx }))
                );

                for (let i = 0; i < allNodes.length; i++) {
                    const node = allNodes[i];

                    // First node verification
                    if (i === 0) {
                        if (grid[tempPos.y][tempPos.x] !== node.char) {
                            failed = true;
                            setMessage(`시작 글자가 '${grid[tempPos.y][tempPos.x]}'이어야 합니다.`);
                            break;
                        }
                        continue;
                    }

                    const prevNode = allNodes[i - 1];
                    let found = false;

                    // Rule Determination:
                    // 1. Intra-Syllable (Same sIdx): Initial -> Final
                    //    -> Consonant Ability (Unlimited, Omnidirectional)
                    // 2. Inter-Syllable (Different sIdx): Final/Initial -> Next Initial
                    //    -> Vowel Ability (Limited, Vowel Direction)

                    const isIntraSyllable = (prevNode.sIdx === node.sIdx);

                    if (isIntraSyllable) {
                        // Consonant Ability: Unlimited, Omnidirectional
                        const directions = [
                            { dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
                            { dx: 1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: 1 }, { dx: -1, dy: -1 }
                        ];

                        for (const d of directions) {
                            for (let step = 1; step <= 4; step++) {
                                const nx = tempPos.x + (d.dx * step);
                                const ny = tempPos.y + (d.dy * step);
                                if (nx >= 0 && nx < 5 && ny >= 0 && ny < 5 && grid[ny][nx] === node.char) {
                                    tempPos.x = nx;
                                    tempPos.y = ny;
                                    found = true;
                                    break;
                                }
                            }
                            if (found) break;
                        }
                        if (!found) setMessage(`자음 능력(글자 내 이동)으로 '${node.char}'에 도달할 수 없습니다.`);

                    } else {
                        // Vowel Ability: Limited, Directional (based on Previous Node's Vowel)
                        const rule = VOWEL_RULES[prevNode.vowel] || { dx: 0, dy: 0 };
                        const dirX = Math.sign(rule.dx);
                        const dirY = Math.sign(rule.dy);
                        const isComplex = ['ㅑ', 'ㅕ', 'ㅛ', 'ㅠ', 'ㅒ', 'ㅖ'].includes(prevNode.vowel);
                        const distLimit = isComplex ? 2 : 1;

                        for (let step = 1; step <= distLimit; step++) {
                            const nx = tempPos.x + (dirX * step);
                            const ny = tempPos.y + (dirY * step);
                            if (nx >= 0 && nx < 5 && ny >= 0 && ny < 5 && grid[ny][nx] === node.char) {
                                tempPos.x = nx;
                                tempPos.y = ny;
                                found = true;
                                break;
                            }
                        }
                        if (!found) setMessage(`모음 능력(다음 글자 이동)으로 '${node.char}'에 도달할 수 없습니다.`);
                    }

                    if (!found) {
                        failed = true;
                        break;
                    }
                }

                if (!failed && tempPos.x === targetPos.x && tempPos.y === targetPos.y) {
                    setCurrentPos(tempPos);
                    setIsWon(true);
                    setMessage(`성공! 정답은 '${inputValue}'였습니다.`);
                    confetti({
                        particleCount: 150,
                        spread: 70,
                        origin: { y: 0.6 }
                    });
                } else if (!failed) {
                    setMessage('목표에 도달하지 못했습니다.');
                }
            };

            return (
                <div className="game-container">
                    <div className="header">
                        <h1 className="title">Hangeul Path</h1>
                        <p className="subtitle">{message}</p>
                    </div>

                    <div className="grid">
                        {grid.map((row, y) =>
                            row.map((char, x) => (
                                <div
                                    key={`${x}-${y}`}
                                    className={`cell ${x === currentPos.x && y === currentPos.y ? 'active' : ''} ${x === targetPos.x && y === targetPos.y ? 'target' : ''}`}
                                >
                                    {char}
                                </div>
                            ))
                        )}
                    </div>

                    <div className="controls">
                        <div className="input-group">
                            <input
                                type="text"
                                placeholder="단어를 입력하세요 (예: 닭, 산...)"
                                value={inputValue}
                                onChange={(e) => setInputValue(e.target.value)}
                                onKeyPress={(e) => e.key === 'Enter' && handleMove()}
                                disabled={isWon}
                            />
                            <button className="btn" onClick={handleMove} disabled={isWon}>
                                이동
                            </button>
                        </div>

                        <div className="rules-hint" style={{ gridTemplateColumns: 'repeat(3, 1fr)' }}>
                            <div className="rule-item"><span className="rule-key">자음 능력 (글자 내)</span><span>한 글자 안에서는 자음끼리 거리 무제한 이동</span></div>
                            <div className="rule-item"><span className="rule-key">모음 능력 (글자 간)</span><span>다음 글자로 갈 때는 모음 방향으로 인접(1~2칸) 이동</span></div>
                        </div>
                        <div className="rules-hint" style={{ marginTop: '0.5rem', gridTemplateColumns: '1fr', textAlign: 'center' }}>
                            <div className="rule-item"><span className="rule-key">게임 목표</span><span>제시된 단어(예: 각, 산...)순서대로 자음을 밟으며 목표 지점까지 이동하세요.</span></div>
                        </div>

                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                            <button className="btn" style={{ background: 'rgba(255,255,255,0.1)', color: 'white', flex: 1 }} onClick={initGame}>
                                게임 재시작
                            </button>
                            <button className="btn" style={{ background: 'rgba(255,255,255,0.05)', color: 'var(--accent-primary)', flex: 1, border: '1px solid rgba(56, 189, 248, 0.2)' }} onClick={() => setShowSolution(!showSolution)}>
                                {showSolution ? '정답 숨기기' : '정답 보기'}
                            </button>
                        </div>
                        {showSolution && (
                            <div className="toast" style={{ position: 'relative', bottom: '0', left: '0', transform: 'none', textAlign: 'center', borderColor: 'var(--accent-secondary)' }}>
                                정답: <span style={{ fontWeight: 'bold', color: 'var(--accent-secondary)' }}>{solution}</span>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<WordPuzzleGame />);
    </script>
</body>

</html>