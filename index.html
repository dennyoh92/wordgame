<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìˆ¨ë°”ê¼­ì§ˆ (Hide and Seek)</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: rgba(30, 41, 59, 0.7);
            --primary-color: #38bdf8;
            --secondary-color: #818cf8;
            --accent-color: #f472b6;
            --text-color: #f8fafc;
            --grid-size: 5;
            --cell-size: clamp(50px, 15vw, 80px);
        }

        @media (max-width: 480px) {
            #game-container {
                padding: 15px;
                border-radius: 16px;
            }

            header h1 {
                font-size: 2rem;
            }

            .cell {
                font-size: 1.2rem;
            }

            .input-group {
                flex-direction: column;
                gap: 5px;
            }

            .secondary-btn,
            #start-btn {
                width: 100%;
            }

            #active-word-display {
                gap: 5px;
            }
        }

        @media (max-width: 380px) {
            #game-grid {
                gap: 6px;
                padding: 6px;
            }

            .cell {
                border-radius: 6px;
            }

            .letter-block {
                padding: 4px 8px;
                font-size: 1rem;
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            -webkit-tap-highlight-color: transparent;
            /* Remove mobile tap highlight */
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100dvh;
            padding: 10px;
            overflow-y: auto;
        }

        #game-container {
            width: 100%;
            max-width: 460px;
            background: var(--card-bg);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            text-align: center;
            padding: 24px;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 5px;
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        header p {
            font-size: 0.9rem;
            color: #94a3b8;
            margin-bottom: 20px;
        }



        #grid-container {
            display: flex;
            justify-content: center;
            margin-bottom: 25px;
            position: relative;
        }

        #game-grid {
            display: grid;
            grid-template-columns: repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            gap: 10px;
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border-radius: 16px;
        }

        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: default;
            transition: all 0.3s ease;
        }

        .cell.start {
            border: 2px solid var(--primary-color);
            background: rgba(56, 189, 248, 0.1);
        }

        .cell.target {
            border: 2px solid var(--accent-color);
            background: rgba(244, 114, 182, 0.15);
            animation: pulse 2s infinite;
            position: relative;
        }

        .cell.target::after {
            content: 'Finish';
            position: absolute;
            bottom: 2px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.6rem;
            font-weight: bold;
            color: var(--accent-color);
            opacity: 0.8;
            pointer-events: none;
        }

        .cell.target.player::after {
            color: rgba(255, 255, 255, 0.9);
        }

        .cell.player {
            background: var(--primary-color);
            color: var(--bg-color);
            box-shadow: 0 0 20px var(--primary-color);
            transform: scale(1.1);
            z-index: 10;
            position: relative;
        }

        .cell.start::after {
            content: 'Start';
            position: absolute;
            bottom: 2px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.6rem;
            font-weight: bold;
            color: var(--primary-color);
            opacity: 1;
            pointer-events: none;
        }

        .cell.start.player::after {
            color: rgba(255, 255, 255, 0.9);
        }

        .cell.active {
            background: rgba(129, 140, 248, 0.3);
            border-color: var(--secondary-color);
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(244, 114, 182, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(244, 114, 182, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(244, 114, 182, 0);
            }
        }

        #control-panel {
            margin-bottom: 20px;
        }

        .input-group {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        #word-input {
            flex: 1;
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 12px 15px;
            color: white;
            font-size: 1rem;
            outline: none;
        }

        #word-input:focus {
            border-color: var(--primary-color);
        }

        #start-btn {
            background: var(--primary-color);
            color: var(--bg-color);
            border: none;
            border-radius: 12px;
            padding: 8px 15px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
        }

        #start-btn:hover {
            background: #7dd3fc;
        }

        .secondary-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 8px 15px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
        }

        .secondary-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .hint-text {
            margin-top: 10px;
            font-size: 0.9rem;
            color: var(--secondary-color);
            font-weight: bold;
            min-height: 1.2em;
        }

        #active-word-display {
            display: flex;
            justify-content: center;
            gap: 10px;
            min-height: 40px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            /* Wrap for mobile */
        }

        .letter-block {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.3s;
        }

        .letter-block.current {
            background: var(--secondary-color);
            transform: translateY(-5px);
        }

        #message-display {
            font-size: 0.9rem;
            color: #94a3b8;
            min-height: 1.5em;
            margin-bottom: 10px;
        }

        #guide-panel {
            text-align: left;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 16px;
            font-size: 0.85rem;
        }

        #guide-panel h3 {
            margin-bottom: 10px;
            font-size: 1rem;
        }

        #guide-panel ul {
            list-style: none;
        }

        #guide-panel li {
            margin-bottom: 8px;
            color: #cbd5e1;
        }

        #action-panel {
            background: rgba(15, 23, 42, 0.5);
            padding: 15px;
            border-radius: 16px;
            border: 1px solid var(--primary-color);
            display: none;
            flex-direction: column;
            gap: 10px;
            margin: 15px auto;
            width: fit-content;
            min-width: 250px;
        }

        #action-panel h3 {
            margin-bottom: 10px;
            color: var(--text-color);
            font-size: 1.2rem;
        }

        .action-btn {
            background: var(--card-bg);
            border: 1px solid var(--secondary-color);
            color: white;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        .action-btn:hover:not(:disabled) {
            background: var(--secondary-color);
            color: var(--bg-color);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #475569;
        }

        .letter-block {
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 12px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1.2rem;
            transition: all 0.3s;
            cursor: pointer;
            border: 2px solid transparent;
        }

        .letter-block:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .letter-block.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
        }

        .letter-block.warped {
            background: rgba(129, 140, 248, 0.4);
            border-color: var(--secondary-color);
            color: white;
            cursor: pointer;
        }

        .letter-block.used {
            background: #475569;
            color: #94a3b8;
            opacity: 0.7;
            text-decoration: line-through;
            cursor: default;
        }

        #guide-panel li strong {
            color: var(--primary-color);
        }

        /* Stage Progress Indicators */
        .stage-indicator-container {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: 10px;
        }

        .stage-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-color);
            opacity: 0.2;
            transition: all 0.3s ease;
        }

        .stage-dot.active {
            opacity: 1;
            background: var(--primary-color);
            transform: scale(1.3);
            box-shadow: 0 0 8px var(--primary-color);
        }

        .stage-dot.completed {
            opacity: 0.6;
            background: var(--primary-color);
        }
    </style>
</head>

<body>
    <div id="game-container">
        <header>
            <h1>ìˆ¨ë°”ê¼­ì§ˆ</h1>
            <div style="display:flex; justify-content:center; align-items:center; gap:12px; margin-bottom:5px;">
                <div id="day-level-display"
                    style="font-size: 0.85rem; color: var(--secondary-color); font-weight: bold;"></div>
                <div id="stage-dots" class="stage-indicator-container">
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                    <div class="stage-dot"></div>
                </div>
                <div id="live-timer"
                    style="font-size: 0.85rem; color: var(--accent-color); font-weight: bold; font-variant-numeric: tabular-nums;">
                </div>
            </div>

        </header>

        <div id="login-overlay"
            style="position: absolute; top:0; left:0; width: 100%; height: 100%; background: var(--bg-color); border-radius: 24px; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; padding: 20px;">
            <div style="margin-bottom: 30px;">
                <h2 style="font-size: 1.8rem; margin-bottom: 10px; color: var(--primary-color);">ì…ì¥ ì¤€ë¹„</h2>
                <p style="color: #94a3b8; font-size: 0.9rem;">ë‹¹ì‹ ì˜ ì´ë¦„ì„ ì•Œë ¤ì£¼ì„¸ìš”.</p>
            </div>
            <div style="width: 100%; max-width: 250px;">
                <input type="text" id="player-id-input" placeholder="í”Œë ˆì´ì–´ ID"
                    style="width: 100%; background: rgba(255,255,255,0.05); border: 1px solid var(--secondary-color); border-radius: 12px; padding: 15px; color: white; text-align: center; font-size: 1.2rem; margin-bottom: 15px; outline: none; box-shadow: 0 0 15px rgba(129, 140, 248, 0.2);">
                <button id="enter-btn"
                    style="width: 100%; background: linear-gradient(135deg, var(--primary-color), var(--secondary-color)); color: var(--bg-color); border: none; border-radius: 12px; padding: 15px; font-weight: bold; font-size: 1.1rem; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;">ì…ì¥í•˜ê¸°</button>
            </div>
            <div id="login-scoreboard"
                style="width:100%; max-width:300px; margin-top:20px; background:rgba(255,255,255,0.05); border-radius:16px; padding:16px; border:1px solid rgba(255,255,255,0.1);">
                <div
                    style="text-align:center; font-weight:bold; color:var(--primary-color); margin-bottom:10px; font-size:0.95rem;">
                    ğŸ† ì˜¤ëŠ˜ì˜ í´ë¦¬ì–´ ë³´ë“œ</div>
                <div id="login-scoreboard-list" style="font-size:0.85rem; color:#94a3b8; text-align:center;">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...
                </div>
            </div>
        </div>

        <div id="briefing-overlay"
            style="display: none; position: absolute; top:0; left:0; width: 100%; height: 100%; background: var(--bg-color); border-radius: 24px; flex-direction: column; justify-content: center; align-items: center; z-index: 90; padding: 24px; text-align: center;">
            <div style="margin-bottom: 25px;">
                <h2 id="briefing-title" style="font-size: 1.6rem; color: var(--primary-color); margin-bottom: 10px;">ë‹¨ê³„
                    ë¸Œë¦¬í•‘</h2>
                <p id="briefing-desc" style="color: #94a3b8; font-size: 0.9rem;">ì´ ë§µì— ëŒ€í•œ ì •ë³´ì…ë‹ˆë‹¤.</p>
            </div>

            <div id="briefing-constraint-info"
                style="background: rgba(255,255,255,0.05); border-radius: 16px; padding: 20px; width: 100%; margin-bottom: 25px; border: 1px solid rgba(255,255,255,0.1);">
                <div id="briefing-constraint-label"
                    style="font-size: 1.2rem; font-weight: bold; color: var(--accent-color);">ì¼ë°˜ ë¬¸ì œ</div>
                <div id="briefing-constraint-desc" style="font-size: 0.85rem; color: #94a3b8; margin-top: 8px;">ììœ ë¡­ê²Œ ë‹¨ì–´ë¥¼
                    ì…ë ¥í•˜ì„¸ìš”.</div>
            </div>

            <button id="start-challenge-btn"
                style="width: 100%; max-width: 200px; background: var(--primary-color); color: var(--bg-color); border: none; border-radius: 12px; padding: 15px; font-weight: bold; font-size: 1.1rem; cursor: pointer; transition: transform 0.2s;">ë„ì „
                ì‹œì‘</button>
        </div>

        <div id="clear-board-overlay"
            style="display: none; position: absolute; top:0; left:0; width: 100%; height: 100%; background: var(--bg-color); border-radius: 24px; flex-direction: column; justify-content: center; align-items: center; z-index: 95; padding: 24px; text-align: center; overflow-y: auto;">
            <div style="margin-bottom: 15px;">
                <h2 style="font-size: 1.6rem; color: var(--primary-color); margin-bottom: 8px;">ğŸ† ì˜¤ëŠ˜ì˜ í´ë¦¬ì–´ ë³´ë“œ</h2>
                <p id="clear-board-date" style="color: #94a3b8; font-size: 0.85rem;"></p>
            </div>
            <div id="clear-board-my-time"
                style="background: rgba(255,255,255,0.08); border-radius: 12px; padding: 15px; width: 100%; margin-bottom: 15px; border: 1px solid rgba(99,102,241,0.3);">
                <div style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 5px;">ë‚´ í´ë¦¬ì–´ ì‹œê°„</div>
                <div id="clear-board-my-time-value"
                    style="font-size: 2rem; font-weight: bold; color: var(--accent-color);">-</div>
            </div>
            <div
                style="background: rgba(255,255,255,0.05); border-radius: 16px; padding: 15px; width: 100%; margin-bottom: 15px; border: 1px solid rgba(255,255,255,0.1);">
                <div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 10px; font-weight: bold;">ğŸ… í´ë¦¬ì–´ ê¸°ë¡</div>
                <div id="clear-board-list"
                    style="font-size: 0.9rem; color: var(--text-color); display: flex; flex-direction: column; gap: 6px;">
                </div>
            </div>
            <button id="clear-board-close-btn"
                style="width: 100%; max-width: 200px; background: rgba(255,255,255,0.1); color: var(--text-color); border: 1px solid rgba(255,255,255,0.2); border-radius: 12px; padding: 12px; font-weight: bold; font-size: 0.95rem; cursor: pointer;">ë‹«ê¸°</button>
        </div>

        <div id="grid-container">
            <script src="dictionary.js"></script>
            <div id="game-grid"></div>
            <div id="constraint-badge"
                style="display: none; position: absolute; top: 10px; right: 10px; background: #ef4444; color: white; padding: 4px 10px; border-radius: 20px; font-size: 0.75rem; font-weight: bold; z-index: 10; box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);">
                3ê¸€ì ì œí•œ</div>
        </div>

        <div id="control-panel">
            <div class="input-group">
                <input type="text" id="word-input" placeholder="ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”" maxlength="10">
                <button id="start-btn">ì´ë™<br>í•˜ê¸°</button>

                <button id="hint-btn" class="secondary-btn">ì •ë‹µ<br>ë³´ê¸°</button>
            </div>

            <div id="action-panel">
                <h3 id="action-title" style="margin-bottom: 8px; color: var(--text-color); font-size: 1.1rem;">ì„ íƒ: ?
                </h3>
                <div style="display: flex; gap: 8px; justify-content: center; width: 100%;">
                    <button id="btn-warp" class="action-btn" style="flex: 1; padding: 10px 5px; font-size: 0.9rem;">ììŒ
                        ì´ë™</button>
                    <button id="btn-move" class="action-btn" style="flex: 1; padding: 10px 5px; font-size: 0.9rem;">ëª¨ìŒ
                        ì´ë™</button>
                </div>
                <button id="btn-close-action" class="secondary-btn"
                    style="margin-top: 5px; height: 36px; padding: 0 10px; font-size: 0.8rem; border-color: rgba(255,255,255,0.2);">ë‹«ê¸°</button>
            </div>
            <div id="active-word-display"></div>
            <div id="message-display">ê²©ì ìœ„ì˜ ììŒì„ ë³´ê³  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</div>
            <div id="hint-display" class="hint-text"></div>

            <div id="guide-panel">
                <h3>ì¡°ì‘ ê°€ì´ë“œ</h3>
                <div
                    style="font-size: 0.8rem; color: var(--secondary-color); margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px; word-break: keep-all; line-height: 1.4;">
                    ì•Œë§ì€ ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ê³  ëª©ì ì§€ê¹Œì§€ ì´ë™í•˜ì„¸ìš”.
                </div>
                <div
                    style="font-size: 0.8rem; color: var(--secondary-color); margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px;">
                    <strong>ììŒ ì´ë™:</strong> ì´ˆì„± â†” ì¢…ì„± ìœ„ì¹˜ë¡œ ì´ë™
                </div>
                <div
                    style="font-size: 0.8rem; color: var(--secondary-color); margin-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 5px;">
                    <strong>ëª¨ìŒ ì´ë™:</strong> ëª¨ìŒ ëª¨ì–‘ì— ë”°ë¼ ì´ë™
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 0.75rem;">
                    <div>ã…, ã… : ì˜¤ë¥¸ìª½ 1ì¹¸ (â†’)</div>
                    <div>ã…‘, ã…’ : ì˜¤ë¥¸ìª½ 2ì¹¸ (â‡‰)</div>
                    <div>ã…“, ã…” : ì™¼ìª½ 1ì¹¸ (â†)</div>
                    <div>ã…•, ã…– : ì™¼ìª½ 2ì¹¸ (â‡‡)</div>
                    <div>ã…—, ã…š : ìœ„ìª½ 1ì¹¸ (â†‘)</div>
                    <div>ã…› : ìœ„ìª½ 2ì¹¸ (â‡ˆ)</div>
                    <div>ã…œ, ã…Ÿ : ì•„ë˜ìª½ 1ì¹¸ (â†“)</div>
                    <div>ã…  : ì•„ë˜ìª½ 2ì¹¸ (â‡Š)</div>
                    <div>ã…˜, ã…™ : ìš°ì¸¡ ìƒë‹¨ (â†—)</div>
                    <div>ã…, ã… : ì¢Œì¸¡ í•˜ë‹¨ (â†™)</div>
                    <div>ã…¡, ã…£, ã…¢ : ì´ë™í•˜ì§€ ì•ŠìŒ (X)</div>
                </div>
            </div>
        </div>

        <script>
            /**
             * Hangeul Word Warp
             * Core Logic and Engine
             */

            // Standardizing Hangeul Jamo to Compatibility Range (U+3131 - U+314E) using explicit Unicode escapes
            // This ensures identical representation across all platforms and editors.
            const CHO = [
                '\u3131', '\u3132', '\u3134', '\u3137', '\u3138', '\u3139', '\u3141', '\u3142', '\u3143', '\u3145',
                '\u3146', '\u3147', '\u3148', '\u3149', '\u314A', '\u314B', '\u314C', '\u314D', '\u314E'
            ];
            const JUNG = [
                '\u314F', '\u3150', '\u3151', '\u3152', '\u3153', '\u3154', '\u3155', '\u3156', '\u3157', '\u3158',
                '\u3159', '\u315A', '\u315B', '\u315C', '\u315D', '\u315E', '\u315F', '\u3160', '\u3161', '\u3162', '\u3163'
            ];
            const JONG = [
                '', '\u3131', '\u3132', '\u3133', '\u3134', '\u3135', '\u3136', '\u3137', '\u3139', '\u313A',
                '\u313B', '\u313C', '\u313D', '\u313E', '\u313F', '\u3140', '\u3141', '\u3142', '\u3144', '\u3145',
                '\u3146', '\u3147', '\u3148', '\u314A', '\u314B', '\u314C', '\u314D', '\u314E'
            ];
            const CONSONANTS = [
                '\u3131', '\u3134', '\u3137', '\u3139', '\u3141', '\u3142',
                '\u3145', '\u3147', '\u3148', '\u314A', '\u314B', '\u314C', '\u314D', '\u314E'
            ];

            const DICTIONARY = [
                'ë¬¼ì‚´', 'ë¶ìª½', 'í•™ê¸°', 'ê³¼í•™', 'ë¬¼í•™', 'ìˆ˜ë°•', 'í•™êµ', 'ë°”ë‹¤', 'ì¶•êµ¬', 'ì‚¬ì', 'ê¸°ì°¨', 'í•˜ëŠ˜', 'í¬ë„', 'ëª¨ì', 'ë‚˜ë¬´', 'ë‚˜ë¹„', 'ìš°ìœ ', 'ì•„ì´', 'ì˜¤ì´',
                'ê°•ë¬¼', 'êµ¬ë¦„', 'ë³„ë¹›', 'ë‹¬ë¹›', 'í–‡ì‚´', 'ë°”ëŒ', 'ì†Œë¦¬', 'ë…¸ë˜', 'ê·¸ë¦¼', 'í¸ì§€', 'ì¹œêµ¬', 'ì‚¬ë‘', 'í–‰ë³µ', 'ë¯¸ì†Œ', 'ê¸°ì¨', 'ìŠ¬í””', 'ìš©ê¸°', 'í¬ë§',
                'ì‚¬ê³¼', 'ì°¸ì™¸', 'ë”¸ê¸°', 'ìˆ˜ë°•', 'í¬ë„', 'ê·¤', 'ì˜¤ë Œì§€', 'ë°”ë‚˜ë‚˜', 'ë§ê³ ', 'ë ˆëª¬', 'ë¼ì„', 'í‚¤ìœ„', 'ìë‘', 'ë³µìˆ­ì•„', 'ì•µë‘', 'ë³´ë¦¬', 'ë²¼',
                'í•œêµ­', 'ì„œìš¸', 'ë¶€ì‚°', 'ëŒ€êµ¬', 'ì¸ì²œ', 'ê´‘ì£¼', 'ëŒ€ì „', 'ìš¸ì‚°', 'ì„¸ì¢…', 'ê²½ê¸°', 'ê°•ì›', 'ì¶©ë¶', 'ì¶©ë‚¨', 'ì „ë¶', 'ì „ë‚¨', 'ê²½ë¶', 'ê²½ë‚¨', 'ì œì£¼'
            ];

            class SeededRandom {
                constructor(seed) {
                    this.state = seed || Math.floor(Math.random() * 2147483647);
                }
                // Mulberry32
                next() {
                    this.state |= 0; this.state = this.state + 0x6D2B79F5 | 0;
                    var t = Math.imul(this.state ^ this.state >>> 15, 1 | this.state);
                    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                    return ((t ^ t >>> 14) >>> 0) / 4294967296;
                }
                nextBetween(min, max) {
                    return Math.floor(this.next() * (max - min)) + min;
                }
                pick(array) {
                    return array[this.nextBetween(0, array.length)];
                }
            }

            class HangeulParser {
                static decompose(syllable) {
                    const code = syllable.charCodeAt(0) - 44032;
                    if (code < 0 || code > 11171) return null;

                    const jongIdx = code % 28;
                    const jungIdx = ((code - jongIdx) / 28) % 21;
                    const choIdx = (((code - jongIdx) / 28) - jungIdx) / 21;

                    return {
                        cho: CHO[choIdx],
                        jung: JUNG[jungIdx],
                        jong: JONG[jongIdx]
                    };
                }
            }

            class GameEngine {
                constructor() {
                    this.gridSize = 5;
                    this.grid = [];
                    this.playerPos = { x: 0, y: 0 };
                    this.targetPos = { x: 4, y: 4 };
                    this.startPos = { x: 0, y: 0 }; // Track start for reset (checkpoint)
                    this.initialStartPos = { x: 0, y: 0 }; // Track initial level start (visual)

                    this.playerId = "";
                    this.currentWord = "";
                    this.letterStates = []; // { char, status: 'unused'|'used', index }
                    this.selectedBlockIndex = -1;
                    this.levelType = 'normal_full';
                    this.minWordLength = 2;

                    this.currentLevelIndex = 0;
                    this.maxLevelsPerDay = 4;
                    this.rng = null;
                    this.startTime = null; // Added startTime

                    // Google Sheets Backend URL (Paste your Web App URL here)
                    this.scriptUrl = "https://script.google.com/macros/s/AKfycbw41O62trdGhB8Zv2vg0ah2QNQmhhPUx8_q639DM1vXfxOQ2-Kh1Oxxtc0CHzpD0VbB/exec";

                    this.isInputLocked = false;
                    this.isWarping = false; // Waiting for target click

                    this.externalDictionary = new Set();
                    this.isDictLoaded = false;

                    this.overallStartTime = null; // Total time across all levels

                    this.init();
                }

                async sendClearTimeToSheet(totalTime) {
                    if (!this.scriptUrl) return;

                    const payload = {
                        action: 'clearBoard',
                        dateId: this.getDailySeed().toString(),
                        playerId: this.playerId || "Anonymous",
                        totalTime: totalTime
                    };

                    try {
                        await fetch(this.scriptUrl, {
                            method: "POST",
                            mode: "no-cors",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });
                    } catch (e) {
                        console.error("Failed to send clear time.", e);
                    }
                }

                async fetchClearBoard() {
                    if (!this.scriptUrl) return null;

                    const dateId = this.getDailySeed();
                    const url = `${this.scriptUrl}?action=clearBoard&dateId=${dateId}`;

                    try {
                        const response = await fetch(url);
                        if (!response.ok) return null;
                        return await response.json();
                    } catch (e) {
                        console.error("Failed to fetch clear board.", e);
                        return null;
                    }
                }

                init() {
                    this.setupDOM();
                    this.loadDictionary();
                    this.initGame();
                }

                async loadDictionary() {
                    // Try to load from window.hangeulDictionary (loaded via script tag)
                    if (window.hangeulDictionary && Array.isArray(window.hangeulDictionary)) {
                        this.externalDictionary = new Set(window.hangeulDictionary);
                        this.isDictLoaded = true;
                        console.log(`Loaded ${window.hangeulDictionary.length} words from dictionary.js`);
                        this.showMessage("ì‚¬ì „ ë°ì´í„° ë¡œë“œ ì™„ë£Œ!");
                        document.getElementById('start-btn').innerHTML = "ê²Œì„<br>ì‹œì‘";
                        document.getElementById('start-btn').disabled = false;
                    } else {
                        // Fallback: Try fetch for json (in case running on server)
                        try {
                            const response = await fetch('dictionary.json');
                            if (!response.ok) throw new Error("Dictionary not found");
                            const words = await response.json();
                            this.externalDictionary = new Set(words);
                            this.isDictLoaded = true;
                            this.showMessage("ì‚¬ì „ ë°ì´í„° ë¡œë“œ ì™„ë£Œ!");
                            document.getElementById('start-btn').innerHTML = "ê²Œì„<br>ì‹œì‘";
                            document.getElementById('start-btn').disabled = false;
                        } catch (e) {
                            console.warn("Failed to load dictionary.", e);
                            this.showMessage("ì‚¬ì „ ë¡œë“œ ì‹¤íŒ¨. ì˜¬ë°”ë¥¸ ë‹¨ì–´ í™•ì¸ì´ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.");
                            document.getElementById('start-btn').innerHTML = "ì‚¬ì „ ì—†ì´<br>ì‹œì‘";
                            document.getElementById('start-btn').disabled = false;
                        }
                    }
                }

                isValidWord(word) {
                    if (this.isDictLoaded) {
                        return this.externalDictionary.has(word);
                    }
                    return true;
                }

                generateSolvableLevel() {
                    const startTime = performance.now();
                    let attempts = 0;
                    let bestLevel = null;

                    while (attempts < 800) {
                        attempts++;
                        const word = this.rng.pick(DICTIONARY);

                        // Level-type specific word filters
                        if (this.levelType === 'long_word' && word.length < 3) continue;
                        if (this.levelType === 'consonant_only') {
                            let hasJong = false;
                            for (const char of word) {
                                const d = HangeulParser.decompose(char);
                                if (d && d.jong) { hasJong = true; break; }
                            }
                            if (!hasJong) continue;
                        }

                        const tempGrid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(""));
                        let currentPos = {
                            x: this.rng.nextBetween(0, this.gridSize),
                            y: this.rng.nextBetween(0, this.gridSize)
                        };
                        const playerStart = { ...currentPos };
                        const pathPositions = [];
                        let possible = true;

                        for (let i = 0; i < word.length; i++) {
                            const char = word[i];
                            const decomposed = HangeulParser.decompose(char);
                            if (!decomposed) { possible = false; break; }

                            const startConsonant = decomposed.cho;
                            if (tempGrid[currentPos.y][currentPos.x] !== "" && tempGrid[currentPos.y][currentPos.x] !== startConsonant) {
                                possible = false; break;
                            }
                            tempGrid[currentPos.y][currentPos.x] = startConsonant;
                            pathPositions.push({ ...currentPos });

                            // Consonant Warp (skip for vowel_only)
                            if (decomposed.jong && this.levelType !== 'vowel_only') {
                                let jumpX, jumpY;
                                let jumpAttempts = 0;
                                do {
                                    jumpX = this.rng.nextBetween(0, this.gridSize);
                                    jumpY = this.rng.nextBetween(0, this.gridSize);
                                    jumpAttempts++;
                                } while ((jumpX === currentPos.x && jumpY === currentPos.y) && jumpAttempts < 20);

                                if (tempGrid[jumpY][jumpX] !== "" && tempGrid[jumpY][jumpX] !== decomposed.jong) {
                                    possible = false; break;
                                }
                                tempGrid[jumpY][jumpX] = decomposed.jong;
                                currentPos = { x: jumpX, y: jumpY };
                                pathPositions.push({ ...currentPos });
                            }

                            // Vowel Move (skip for consonant_only)
                            if (this.levelType !== 'consonant_only') {
                                let dx = 0, dy = 0;
                                const vowel = decomposed.jung;
                                switch (vowel) {
                                    case 'ã…': case 'ã…': dx = 1; break;
                                    case 'ã…‘': case 'ã…’': dx = 2; break;
                                    case 'ã…“': case 'ã…”': dx = -1; break;
                                    case 'ã…•': case 'ã…–': dx = -2; break;
                                    case 'ã…—': case 'ã…š': dy = -1; break;
                                    case 'ã…›': dy = -2; break;
                                    case 'ã…œ': case 'ã…Ÿ': dy = 1; break;
                                    case 'ã… ': dy = 2; break;
                                    case 'ã…˜': case 'ã…™': dx = 1; dy = -1; break;
                                    case 'ã…': dx = -1; dy = 1; break;
                                }
                                const nextX = currentPos.x + dx;
                                const nextY = currentPos.y + dy;

                                if (nextX < 0 || nextX >= this.gridSize || nextY < 0 || nextY >= this.gridSize) {
                                    possible = false; break;
                                }
                                currentPos = { x: nextX, y: nextY };
                            }
                        }

                        if (possible) {
                            const target = { ...currentPos };
                            const manhattan = Math.abs(playerStart.x - target.x) + Math.abs(playerStart.y - target.y);
                            if (manhattan >= 2) {
                                // For no_adjacent: ensure path doesn't go through target-adjacent cells
                                if (this.levelType === 'no_adjacent') {
                                    const adjSet = new Set();
                                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dx, dy]) => {
                                        adjSet.add(`${target.x + dx},${target.y + dy}`);
                                    });
                                    if (pathPositions.some(p => adjSet.has(`${p.x},${p.y}`))) continue;
                                }

                                // Fill empty cells with random consonants
                                for (let y = 0; y < this.gridSize; y++) {
                                    for (let x = 0; x < this.gridSize; x++) {
                                        if (tempGrid[y][x] === "") {
                                            tempGrid[y][x] = CONSONANTS[this.rng.nextBetween(0, CONSONANTS.length)];
                                        }
                                    }
                                }

                                bestLevel = {
                                    grid: tempGrid,
                                    playerPos: playerStart,
                                    targetPos: target,
                                    path: pathPositions
                                };
                                break;
                            }
                        }
                    }

                    if (bestLevel) {
                        this.grid = bestLevel.grid;
                        this.playerPos = bestLevel.playerPos;
                        this.targetPos = bestLevel.targetPos;

                        // Apply pruning only for no_adjacent
                        if (this.levelType === 'no_adjacent') {
                            this.pruneGrid(bestLevel.path);
                        }

                        const endTime = performance.now();
                        console.log(`Level [${this.levelType}] generated in ${attempts} attempts (${(endTime - startTime).toFixed(2)}ms)`);
                    } else {
                        this.randomizePointsSeeded();
                        this.createGridSeeded();
                        console.warn("Construction failed, fallback to random seeded.");
                    }
                }

                calculatePathPenalty(path) {
                    if (!path) return Infinity;
                    let penalty = 0;
                    path.forEach(pos => {
                        const dist = Math.abs(pos.x - this.targetPos.x) + Math.abs(pos.y - this.targetPos.y);
                        if (dist === 1) penalty += 10;
                    });
                    return penalty;
                }

                pruneGrid(path) {
                    if (!path) return;
                    const used = new Set(path.map(p => `${p.x},${p.y}`));
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dx = -1; dx <= 1; dx++) {
                            if (Math.abs(dx) + Math.abs(dy) !== 1) continue;
                            const nx = this.targetPos.x + dx;
                            const ny = this.targetPos.y + dy;
                            if (nx >= 0 && nx < this.gridSize && ny >= 0 && ny < this.gridSize) {
                                if (!used.has(`${nx},${ny}`)) {
                                    this.grid[ny][nx] = "";
                                }
                            }
                        }
                    }
                    const candidates = [];
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            if (x === this.targetPos.x && y === this.targetPos.y) continue;
                            if (this.grid[y][x] !== "" && !used.has(`${x},${y}`)) {
                                candidates.push({ x, y });
                            }
                        }
                    }
                    candidates.sort((a, b) => {
                        const distA = Math.abs(a.x - this.targetPos.x) + Math.abs(a.y - this.targetPos.y);
                        const distB = Math.abs(b.x - this.targetPos.x) + Math.abs(b.y - this.targetPos.y);
                        return distB - distA;
                    });
                    const alreadyRemoved = this.grid.flat().filter(c => c === "").length - 1;
                    const maxToRemove = 15 - alreadyRemoved;
                    if (maxToRemove > 0) {
                        const extraRemove = candidates.slice(0, maxToRemove);
                        extraRemove.forEach(pos => {
                            this.grid[pos.y][pos.x] = "";
                        });
                    }
                }

                getDailySeed() {
                    const now = new Date();
                    const y = now.getFullYear();
                    const m = String(now.getMonth() + 1).padStart(2, '0');
                    const d = String(now.getDate()).padStart(2, '0');
                    return parseInt(`${y}${m}${d}`);
                }

                determineLevelType() {
                    const allCases = ['consonant_only', 'vowel_only', 'no_adjacent', 'normal'];
                    if (this.currentLevelIndex === 0) {
                        this.levelType = 'normal_full';
                        this.minWordLength = 2;
                    } else if (this.currentLevelIndex === 1 || this.currentLevelIndex === 2) {
                        if (this.currentLevelIndex === 1) {
                            this.levelType = this.rng.pick(allCases);
                        } else {
                            // Re-derive level 2's type to avoid same type
                            const level2Rng = new SeededRandom(this.getDailySeed() + 1);
                            const level2Type = level2Rng.pick(allCases);
                            const remaining = allCases.filter(t => t !== level2Type);
                            this.levelType = this.rng.pick(remaining);
                        }
                        this.minWordLength = 2;
                    } else {
                        this.levelType = 'long_word';
                        this.minWordLength = 3;
                    }
                }

                updateConstraintBadge() {
                    const badge = this.constraintBadge;
                    badge.style.display = 'none';
                    return; // Disable badge display
                    switch (this.levelType) {
                        case 'normal_full':
                        case 'normal':
                            badge.style.display = 'none';
                            this.showMessage("ê²©ì ìœ„ì˜ ììŒì„ ë³´ê³  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
                            break;
                        case 'consonant_only':
                            badge.textContent = 'ì›Œí”„ë§Œ ê°€ëŠ¥';
                            badge.style.background = '#8b5cf6';
                            this.showMessage("ììŒ ì›Œí”„ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤! ëª¨ìŒ ì´ë™ì€ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.");
                            break;
                        case 'vowel_only':
                            badge.textContent = 'ì´ë™ë§Œ ê°€ëŠ¥';
                            badge.style.background = '#f59e0b';
                            this.showMessage("ëª¨ìŒ ì´ë™ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤! ììŒ ì›Œí”„ëŠ” ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.");
                            break;
                        case 'no_adjacent':
                            badge.textContent = 'ëª©í‘œ ì¸ì ‘ ë¹ˆì¹¸';
                            badge.style.background = '#ef4444';
                            this.showMessage("ë¹ˆì¹¸ë“¤ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤!");
                            break;
                        case 'long_word':
                            badge.textContent = '3ê¸€ì ì´ìƒ';
                            badge.style.background = '#ef4444';
                            this.showMessage("3ê¸€ì ì´ìƒ ë‹¨ì–´ë¡œ ëª©í‘œì— ë„ë‹¬í•˜ì„¸ìš”!");
                            break;
                    }
                }

                randomizePointsSeeded() {
                    do {
                        this.playerPos = {
                            x: this.rng.nextBetween(0, this.gridSize),
                            y: this.rng.nextBetween(0, this.gridSize)
                        };
                        this.targetPos = {
                            x: this.rng.nextBetween(0, this.gridSize),
                            y: this.rng.nextBetween(0, this.gridSize)
                        };
                    } while (Math.abs(this.playerPos.x - this.targetPos.x) + Math.abs(this.playerPos.y - this.targetPos.y) < 3);
                }

                createGridSeeded() {
                    this.grid = [];
                    for (let y = 0; y < this.gridSize; y++) {
                        const row = [];
                        for (let x = 0; x < this.gridSize; x++) {
                            if (x === this.targetPos.x && y === this.targetPos.y) {
                                row.push("");
                            } else {
                                const randomConsonant = CONSONANTS[this.rng.nextBetween(0, CONSONANTS.length)];
                                row.push(randomConsonant);
                            }
                        }
                        this.grid.push(row);
                    }
                }

                setupDOM() {
                    this.gridEl = document.getElementById('game-grid');
                    this.inputEl = document.getElementById('word-input');
                    this.startBtn = document.getElementById('start-btn');

                    this.messageEl = document.getElementById('message-display');
                    this.wordDisplayEl = document.getElementById('active-word-display');
                    this.dayLevelDisplayEl = document.getElementById('day-level-display');
                    this.liveTimerEl = document.getElementById('live-timer');
                    this.stageDots = document.querySelectorAll('.stage-dot');
                    this.timerInterval = null;

                    this.hintBtn = document.getElementById('hint-btn');
                    this.hintDisplayEl = document.getElementById('hint-display');
                    this.hintInterval = null;

                    // Briefing Elements
                    this.briefingOverlay = document.getElementById('briefing-overlay');
                    this.briefingTitle = document.getElementById('briefing-title');
                    this.briefingConstraintLabel = document.getElementById('briefing-constraint-label');
                    this.briefingConstraintDesc = document.getElementById('briefing-constraint-desc');
                    this.startChallengeBtn = document.getElementById('start-challenge-btn');

                    // Clear Board Elements
                    this.clearBoardOverlay = document.getElementById('clear-board-overlay');
                    this.clearBoardDate = document.getElementById('clear-board-date');
                    this.clearBoardMyTime = document.getElementById('clear-board-my-time-value');
                    this.clearBoardList = document.getElementById('clear-board-list');
                    document.getElementById('clear-board-close-btn').onclick = () => {
                        this.clearBoardOverlay.style.display = 'none';
                    };

                    this.startChallengeBtn.onclick = () => {
                        this.briefingOverlay.style.display = 'none';
                        this.startTime = Date.now();
                        if (this.currentLevelIndex === 0) {
                            this.overallStartTime = Date.now();
                        }
                    };



                    // Login/ID Elements
                    this.loginOverlay = document.getElementById('login-overlay');
                    this.playerIdInput = document.getElementById('player-id-input');
                    this.enterBtn = document.getElementById('enter-btn');

                    // Fetch and display today's scoreboard on login screen
                    this.loadLoginScoreboard();

                    this.enterBtn.onclick = () => {
                        const id = this.playerIdInput.value.trim();
                        if (id) {
                            this.playerId = id;
                            this.loginOverlay.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                            this.loginOverlay.style.opacity = '0';
                            this.loginOverlay.style.transform = 'scale(1.1)';
                            setTimeout(() => {
                                this.loginOverlay.style.display = 'none';
                                this.showMessage(`${this.playerId}ë‹˜, í™˜ì˜í•©ë‹ˆë‹¤.`);
                            }, 500);
                        } else {
                            this.playerIdInput.style.animation = 'shake 0.5s';
                            setTimeout(() => this.playerIdInput.style.animation = '', 500);
                        }
                    };

                    // Add shake animation style dynamically if not present
                    if (!document.getElementById('shake-style')) {
                        const style = document.createElement('style');
                        style.id = 'shake-style';
                        style.textContent = `
                            @keyframes shake {
                                0%, 100% { transform: translateX(0); }
                                25% { transform: translateX(-5px); }
                                75% { transform: translateX(5px); }
                            }
                        `;
                        document.head.appendChild(style);
                    }

                    // Action Panel
                    this.actionPanel = document.getElementById('action-panel');
                    this.actionTitle = document.getElementById('action-title');
                    this.btnWarp = document.getElementById('btn-warp');
                    this.btnMove = document.getElementById('btn-move');
                    this.constraintBadge = document.getElementById('constraint-badge');

                    this.startBtn.onclick = () => this.handleStart();
                    this.hintBtn.onclick = () => this.showHint();
                    this.inputEl.onkeypress = (e) => {
                        if (e.key === 'Enter') this.handleStart();
                    };

                    // Grid Click
                    this.gridEl.onclick = (e) => {
                        const cell = e.target.closest('.cell');
                        if (!cell) return;

                        if (this.isWarping) {
                            const idx = Array.from(this.gridEl.children).indexOf(cell);
                            const x = idx % this.gridSize;
                            const y = Math.floor(idx / this.gridSize);

                            // Check if valid target
                            if (cell.classList.contains('active')) {
                                this.resolveWarp({ x, y });
                            } else {
                                // Cancel warping if clicked elsewhere
                                this.isWarping = false;
                                this.clearHighlights();
                                this.showMessage("ì›Œí”„ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì„ íƒí•˜ì„¸ìš”.");
                                this.selectBlock(this.selectedBlockIndex);
                            }
                        }
                    };

                    this.btnWarp.onclick = () => this.initiateWarp();
                    this.btnMove.onclick = () => this.initiateMove();
                    document.getElementById('btn-close-action').onclick = () => this.hideActionPanel();
                }

                async showBriefing() {
                    this.briefingTitle.textContent = `${this.currentLevelIndex + 1}ë‹¨ê³„`;

                    // Show constraint info based on level type
                    switch (this.levelType) {
                        case 'normal_full':
                            this.briefingConstraintLabel.textContent = 'ì¼ë°˜ ë¬¸ì œ';
                            this.briefingConstraintDesc.textContent = 'ëª¨ë“  ì¹¸ì— ììŒì´ ì°¨ ìˆìŠµë‹ˆë‹¤. ììœ ë¡­ê²Œ ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                            this.briefingConstraintLabel.style.color = 'var(--accent-color)';
                            break;
                        case 'consonant_only':
                            this.briefingConstraintLabel.textContent = 'ğŸŸ£ ì›Œí”„ë§Œ ê°€ëŠ¥';
                            this.briefingConstraintDesc.textContent = 'ììŒ ì›Œí”„ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ëª¨ìŒ ì´ë™ì€ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.';
                            this.briefingConstraintLabel.style.color = '#8b5cf6';
                            break;
                        case 'vowel_only':
                            this.briefingConstraintLabel.textContent = 'ğŸŸ¡ ì´ë™ë§Œ ê°€ëŠ¥';
                            this.briefingConstraintDesc.textContent = 'ëª¨ìŒ ì´ë™ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ììŒ ì›Œí”„ëŠ” ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.';
                            this.briefingConstraintLabel.style.color = '#f59e0b';
                            break;
                        case 'no_adjacent':
                            this.briefingConstraintLabel.textContent = 'ğŸ”´ ëª©í‘œ ì¸ì ‘ ë¹ˆì¹¸';
                            this.briefingConstraintDesc.textContent = 'ë¹ˆì¹¸ë“¤ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.';
                            this.briefingConstraintLabel.style.color = '#ef4444';
                            break;
                        case 'normal':
                            this.briefingConstraintLabel.textContent = 'ì¼ë°˜ ë¬¸ì œ';
                            this.briefingConstraintDesc.textContent = 'ììœ ë¡­ê²Œ ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                            this.briefingConstraintLabel.style.color = 'var(--accent-color)';
                            break;
                        case 'long_word':
                            this.briefingConstraintLabel.textContent = 'ğŸ”´ 3ê¸€ì ì´ìƒ';
                            this.briefingConstraintDesc.textContent = '3ê¸€ì ì´ìƒ ë‹¨ì–´ë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
                            this.briefingConstraintLabel.style.color = '#ef4444';
                            break;
                    }

                    this.briefingOverlay.style.display = 'flex';
                }

                async showClearBoard(myTotalTime) {
                    const seed = this.getDailySeed();
                    const dayString = seed.toString().replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');
                    this.clearBoardDate.textContent = dayString;

                    // Show my time
                    if (myTotalTime) {
                        this.clearBoardMyTime.textContent = `${myTotalTime}ì´ˆ`;
                    } else {
                        this.clearBoardMyTime.textContent = '-';
                    }

                    // Fetch leaderboard
                    this.clearBoardList.innerHTML = '<div style="color: #64748b">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>';
                    this.clearBoardOverlay.style.display = 'flex';

                    const data = await this.fetchClearBoard();
                    this.clearBoardList.innerHTML = '';

                    if (data && data.entries && data.entries.length > 0) {
                        data.entries
                            .sort((a, b) => a.totalTime - b.totalTime)
                            .forEach((entry, i) => {
                                const row = document.createElement('div');
                                row.style.cssText = 'display:flex; justify-content:space-between; padding:4px 0;';
                                const medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : i === 2 ? 'ğŸ¥‰' : `${i + 1}.`;
                                const isMe = entry.playerId === this.playerId;
                                row.innerHTML = `<span style="${isMe ? 'color:var(--accent-color);font-weight:bold' : ''}">${medal} ${entry.playerId}</span><span style="color: var(--secondary-color)">${entry.totalTime}ì´ˆ</span>`;
                                this.clearBoardList.appendChild(row);
                            });
                    } else {
                        this.clearBoardList.innerHTML = '<div style="color: #64748b; text-align:center; padding:16px;">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                    }
                }

                async loadLoginScoreboard() {
                    const listEl = document.getElementById('login-scoreboard-list');
                    try {
                        const data = await this.fetchClearBoard();
                        listEl.innerHTML = '';
                        if (data && data.entries && data.entries.length > 0) {
                            data.entries
                                .sort((a, b) => a.totalTime - b.totalTime)
                                .forEach((entry, i) => {
                                    const row = document.createElement('div');
                                    row.style.cssText = 'display:flex; justify-content:space-between; padding:3px 0;';
                                    const medal = i === 0 ? 'ğŸ¥‡' : i === 1 ? 'ğŸ¥ˆ' : i === 2 ? 'ğŸ¥‰' : `${i + 1}.`;
                                    row.innerHTML = `<span>${medal} ${entry.playerId}</span><span style="color:var(--secondary-color)">${entry.totalTime}ì´ˆ</span>`;
                                    listEl.appendChild(row);
                                });
                        } else {
                            listEl.innerHTML = 'ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤. ì²« ë²ˆì§¸ ë„ì „ìê°€ ë˜ì„¸ìš”!';
                        }
                    } catch (e) {
                        listEl.innerHTML = 'ê¸°ë¡ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.';
                    }
                }



                updateStageDots() {
                    this.stageDots.forEach((dot, index) => {
                        dot.classList.remove('active', 'completed');
                        if (index < this.currentLevelIndex) {
                            dot.classList.add('completed');
                        } else if (index === this.currentLevelIndex) {
                            dot.classList.add('active');
                        }
                    });
                }

                render() {
                    this.gridEl.innerHTML = '';
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            cell.textContent = this.grid[y][x];

                            if (x === this.initialStartPos.x && y === this.initialStartPos.y) {
                                cell.classList.add('start');
                            }
                            if (x === this.targetPos.x && y === this.targetPos.y) {
                                cell.classList.add('target');
                            }
                            if (x === this.playerPos.x && y === this.playerPos.y) {
                                cell.classList.add('player');
                            }

                            this.gridEl.appendChild(cell);
                        }
                    }

                }

                async handleStart() {
                    if (this.isInputLocked && this.letterStates.length > 0) return;

                    const word = this.inputEl.value.trim().normalize('NFC');
                    if (!word) {
                        this.showMessage("ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”!");
                        return;
                    }

                    if (word.length < this.minWordLength) {
                        this.showMessage(`ë‹¨ì–´ëŠ” ìµœì†Œ ${this.minWordLength}ê¸€ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤!`);
                        return;
                    }

                    // Validate Word
                    if (this.isDictLoaded && !this.isValidWord(word)) {
                        this.showMessage(`'${word}'ì€(ëŠ”) ì‚¬ì „ì— ì—†ëŠ” ë‹¨ì–´ì…ë‹ˆë‹¤.`);
                        return;
                    }

                    this.startPos = { ...this.playerPos };
                    this.currentWord = word;

                    // Initialize Letter States
                    this.letterStates = Array.from(word).map((char, index) => ({
                        char,
                        index,
                        status: 'unused', // unused, used
                        decomposed: HangeulParser.decompose(char)
                    }));

                    this.isInputLocked = true;
                    this.inputEl.disabled = true;
                    this.inputEl.value = "";
                    this.startBtn.innerHTML = "ë‹¤ì‹œ<br>í•˜ê¸°";
                    this.startBtn.onclick = () => this.resetGame();

                    this.renderWordBlocks();
                    this.showMessage("ê²©ì ìœ„ì˜ ììŒê³¼ ì¼ì¹˜í•˜ëŠ” ê¸€ìë¥¼ í´ë¦­í•˜ì„¸ìš”.");
                    this.isWarping = false;
                    this.hideActionPanel();
                }

                resetGame() {
                    this.isInputLocked = false;
                    this.inputEl.disabled = false;
                    this.startBtn.innerHTML = "ì´ë™<br>í•˜ê¸°";
                    this.startBtn.onclick = () => this.handleStart();
                    this.letterStates = [];
                    this.resetToStartPos();
                    this.renderWordBlocks();
                    this.hideActionPanel();
                    this.clearHighlights();
                    this.showMessage("ê²©ì ìœ„ì˜ ììŒì„ ë³´ê³  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
                }

                resetToStartPos() {
                    this.playerPos = { ...this.startPos };
                    this.render();
                }

                resetToStartAndRetry() {
                    this.showMessage("ì¡°ê±´ ë¶ˆì¼ì¹˜! ì²˜ìŒ ìœ„ì¹˜ë¡œ ëŒì•„ê°‘ë‹ˆë‹¤.");
                    this.resetToStartPos();
                    // Reset states
                    this.letterStates.forEach(s => s.status = 'unused');
                    this.renderWordBlocks();
                    this.hideActionPanel();
                    this.clearHighlights();
                    this.isWarping = false;
                }

                isSameJamo(a, b) {
                    if (!a || !b) return false;
                    const aN = a.normalize('NFC');
                    const bN = b.normalize('NFC');
                    if (aN === bN) return true;
                    // Fallback to code comparison if normalization fails to unify
                    return aN.charCodeAt(0) === bN.charCodeAt(0);
                }

                startNewLevel() {
                    this.initGame();
                }

                initGame() {
                    const seed = this.getDailySeed();
                    const dayString = seed.toString().replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3');

                    if (this.currentLevelIndex >= this.maxLevelsPerDay) {
                        this.dayLevelDisplayEl.textContent = `Day ${dayString} - ë„ì „ ì™„ë£Œ!`;
                        this.showMessage("ì˜¤ëŠ˜ì˜ ëª¨ë“  ë„ì „ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤! ë‚´ì¼ ë‹¤ì‹œ ì˜¤ì„¸ìš”.");
                        this.inputEl.disabled = true;
                        this.startBtn.disabled = true;
                        if (this.timerInterval) clearInterval(this.timerInterval);
                        this.liveTimerEl.textContent = '';
                        this.updateStageDots();
                        this.showClearBoard(null); // Show clear board on revisit
                        return;
                    }

                    // Create RNG for this level
                    this.rng = new SeededRandom(seed + this.currentLevelIndex);
                    this.determineLevelType();

                    this.dayLevelDisplayEl.textContent = `Day ${dayString}`;
                    this.updateStageDots();
                    this.inputEl.value = "";
                    this.wordDisplayEl.innerHTML = "";
                    this.generateSolvableLevel();
                    this.startPos = { ...this.playerPos };
                    this.initialStartPos = { ...this.playerPos }; // Save initial start for visual label
                    this.render();

                    // Start timer immediately
                    this.startTime = Date.now();
                    if (this.currentLevelIndex === 0) {
                        this.overallStartTime = Date.now();
                    }

                    // Start live timer display
                    if (this.timerInterval) clearInterval(this.timerInterval);
                    this.timerInterval = setInterval(() => {
                        if (this.overallStartTime) {
                            const elapsed = ((Date.now() - this.overallStartTime) / 1000).toFixed(1);
                            this.liveTimerEl.textContent = `â± ${elapsed}ì´ˆ`;
                        }
                    }, 100);

                    // Start Hint Timer (3 minutes)
                    if (this.hintInterval) clearInterval(this.hintInterval);
                    this.hintBtn.disabled = true;
                    this.hintBtn.style.opacity = '0.5';
                    this.hintBtn.style.cursor = 'not-allowed';

                    let hintTimeLeft = 180; // 3 minutes
                    const updateHintBtn = () => {
                        const m = Math.floor(hintTimeLeft / 60);
                        const s = hintTimeLeft % 60;
                        this.hintBtn.innerHTML = `ì •ë‹µ<br>ë³´ê¸°<br>(${m}:${s.toString().padStart(2, '0')})`;
                    };
                    updateHintBtn();

                    this.hintInterval = setInterval(() => {
                        hintTimeLeft--;
                        if (hintTimeLeft <= 0) {
                            clearInterval(this.hintInterval);
                            this.hintBtn.disabled = false;
                            this.hintBtn.style.opacity = '1';
                            this.hintBtn.style.cursor = 'pointer';
                            this.hintBtn.innerHTML = "ì •ë‹µ<br>ë³´ê¸°";
                        } else {
                            updateHintBtn();
                        }
                    }, 1000);

                    // Show constraint info as message
                    this.updateConstraintBadge();
                    switch (this.levelType) {
                        case 'normal_full': this.showMessage('ê²©ì ìœ„ì˜ ììŒì„ ë³´ê³  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.'); break;
                        case 'consonant_only': this.showMessage('ğŸŸ  ì›Œí”„ë§Œ ê°€ëŠ¥! ëª¨ìŒ ì´ë™ì€ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.'); break;
                        case 'vowel_only': this.showMessage('ğŸŸ¡ ì´ë™ë§Œ ê°€ëŠ¥! ììŒ ì›Œí”„ëŠ” ë¹„í™œì„±í™”ë©ë‹ˆë‹¤.'); break;
                        case 'no_adjacent': this.showMessage('ğŸ”´ ë¹ˆì¹¸ë“¤ì´ ë‚˜íƒ€ë‚©ë‹ˆë‹¤.'); break;
                        case 'normal': this.showMessage('ê²©ì ìœ„ì˜ ììŒì„ ë³´ê³  ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.'); break;
                        case 'long_word': this.showMessage('ğŸ”´ 3ê¸€ì ì´ìƒ ë‹¨ì–´ë§Œ ì‚¬ìš© ê°€ëŠ¥!'); break;
                    }
                }

                async checkWinCondition() {
                    if (this.playerPos.x === this.targetPos.x && this.playerPos.y === this.targetPos.y) {
                        const allProcessed = this.letterStates.every(s => s.status === 'used' || s.status === 'warped' || s.status === 'moved');

                        if (allProcessed) {
                            this.currentLevelIndex++;
                            if (this.currentLevelIndex < this.maxLevelsPerDay) {
                                this.showMessage(`ğŸ‰ ë‹¨ê³„ í´ë¦¬ì–´! ${this.currentLevelIndex + 1}ë‹¨ê³„ë¡œ ì´ë™í•©ë‹ˆë‹¤...`);
                                setTimeout(() => {
                                    this.isInputLocked = false;
                                    this.inputEl.disabled = false;
                                    this.startBtn.innerHTML = "ì´ë™<br>í•˜ê¸°";
                                    this.initGame();
                                }, 1500);
                            } else {
                                // All 4 levels cleared!
                                if (this.timerInterval) clearInterval(this.timerInterval);
                                if (this.hintInterval) clearInterval(this.hintInterval);
                                const totalTime = ((Date.now() - this.overallStartTime) / 1000).toFixed(1);
                                this.liveTimerEl.textContent = `â± ${totalTime}ì´ˆ âœ…`;
                                this.showMessage(`ğŸŠ ì˜¤ëŠ˜ì˜ ëª¨ë“  ë„ì „ì„ ì™„ë£Œí–ˆìŠµë‹ˆë‹¤! ì´ ${totalTime}ì´ˆ`);
                                this.sendClearTimeToSheet(totalTime);
                                setTimeout(async () => {
                                    this.initGame();
                                    await this.showClearBoard(totalTime);
                                }, 1500);
                            }
                            return true;
                        } else {
                            this.showMessage("ëª¨ë“  ê¸€ìë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.");
                            return false;
                        }
                    }

                    const allDone = this.letterStates.every(s => s.status === 'used');
                    if (allDone) {
                        this.resetToStartAndRetry();
                        return false;
                    }

                    return false;
                }

                showHint() {
                    const solutions = this.findSolutions();
                    if (solutions.length > 0) {
                        // Show the shortest or first valid solution
                        const best = solutions.sort((a, b) => a.length - b.length)[0];
                        this.hintDisplayEl.textContent = `ì¶”ì²œ ë‹¨ì–´: ${best}`;
                    } else {
                        this.hintDisplayEl.textContent = "í˜„ì¬ ìœ„ì¹˜ì—ì„œ ë„ë‹¬ ê°€ëŠ¥í•œ ë‹¨ì–´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.";
                    }
                }

                findSolutions(dictSource = null) {
                    const results = [];
                    // Use provided dictSource OR the best available dictionary
                    const dict = dictSource || (this.isDictLoaded ? Array.from(this.externalDictionary) : DICTIONARY);

                    for (const word of dict) {
                        if (word.length < this.minWordLength) continue;
                        if (this.simulateWord(word)) {
                            results.push(word);
                        }
                    }
                    return results;
                }

                simulateWord(word) {
                    // Try to simulate from a given position and character index
                    const self = this;

                    function simulate(pos, charIdx) {
                        if (charIdx >= word.length) {
                            // All characters processed - check if at target
                            return (pos.x === self.targetPos.x && pos.y === self.targetPos.y) ? [] : null;
                        }

                        const char = word[charIdx];
                        const decomposed = HangeulParser.decompose(char);
                        if (!decomposed) return null;

                        const currentConsonant = self.grid[pos.y][pos.x];
                        const canActivate = (currentConsonant === decomposed.cho || (decomposed.jong && currentConsonant === decomposed.jong));
                        if (!canActivate) return null;

                        // Determine warp targets
                        let warpPositions = [{ ...pos }]; // default: no warp, stay at current pos

                        if (decomposed.jong && self.levelType !== 'vowel_only') {
                            let targetConsonant = "";
                            if (currentConsonant === decomposed.cho) targetConsonant = decomposed.jong;
                            else if (currentConsonant === decomposed.jong) targetConsonant = decomposed.cho;

                            if (targetConsonant) {
                                const potentialTargets = [];
                                for (let y = 0; y < self.gridSize; y++) {
                                    for (let x = 0; x < self.gridSize; x++) {
                                        if (self.grid[y][x] === targetConsonant && (x !== pos.x || y !== pos.y)) {
                                            potentialTargets.push({ x, y });
                                        }
                                    }
                                }
                                if (potentialTargets.length > 0) {
                                    warpPositions = potentialTargets; // try all warp targets
                                }
                            }
                        }

                        // Try each warp position
                        for (const warpPos of warpPositions) {
                            let nextPos = { ...warpPos };

                            // Apply vowel move (skip for consonant_only)
                            if (self.levelType !== 'consonant_only') {
                                let dx = 0, dy = 0;
                                const vowel = decomposed.jung;
                                switch (vowel) {
                                    case '\u314f': case '\u3150': dx = 1; break;
                                    case '\u3151': case '\u3152': dx = 2; break;
                                    case '\u3153': case '\u3154': dx = -1; break;
                                    case '\u3155': case '\u3156': dx = -2; break;
                                    case '\u3157': case '\u315a': dy = -1; break;
                                    case '\u315b': dy = -2; break;
                                    case '\u315c': case '\u315f': dy = 1; break;
                                    case '\u3160': dy = 2; break;
                                    case '\u3158': case '\u3159': dx = 1; dy = -1; break;
                                    case '\u315d': dx = -1; dy = 1; break;
                                }
                                nextPos.x += dx;
                                nextPos.y += dy;

                                // Reject out-of-bounds (same as generateSolvableLevel)
                                if (nextPos.x < 0 || nextPos.x >= self.gridSize || nextPos.y < 0 || nextPos.y >= self.gridSize) {
                                    continue; // try next warp target
                                }
                            }

                            // Recurse to next character
                            const result = simulate(nextPos, charIdx + 1);
                            if (result !== null) {
                                return [{ ...pos }, ...result];
                            }
                        }
                        return null;
                    }

                    return simulate({ ...this.playerPos }, 0);
                }

                renderWordBlocks() {
                    this.wordDisplayEl.innerHTML = '';
                    this.letterStates.forEach(state => {
                        const block = document.createElement('div');
                        block.className = `letter-block ${state.status}`;
                        if (this.selectedBlockIndex === state.index) block.classList.add('selected');
                        block.textContent = state.char;

                        block.onclick = () => {
                            if (state.status === 'used') return;
                            if (state.status === 'moved' || state.status === 'warped') {
                                this.selectBlock(state.index);
                                return;
                            }
                            this.selectBlock(state.index);
                        };

                        this.wordDisplayEl.appendChild(block);
                    });
                }

                selectBlock(index) {
                    if (this.isWarping) {
                        this.isWarping = false;
                        this.clearHighlights();
                        this.showMessage("ì›Œí”„ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.");
                    }
                    this.selectedBlockIndex = index;
                    this.renderWordBlocks();

                    const state = this.letterStates[index];
                    const dec = state.decomposed;

                    if (!dec) {
                        this.showMessage("ìœ íš¨í•˜ì§€ ì•Šì€ ê¸€ìì…ë‹ˆë‹¤.");
                        return;
                    }

                    this.actionTitle.textContent = `ì„ íƒ: '${state.char}'`;
                    this.actionPanel.style.display = 'flex';

                    // Validate Actions
                    const cellRaw = this.grid[this.playerPos.y][this.playerPos.x];
                    const currentConsonant = cellRaw ? cellRaw.normalize('NFC') : "";
                    const cho = dec.cho.normalize('NFC');
                    const jong = dec.jong ? dec.jong.normalize('NFC') : null;

                    console.log(`Diagnostic [selectBlock]: Cell='${currentConsonant}'(${currentConsonant.charCodeAt(0)}), Cho='${cho}'(${cho.charCodeAt(0)}), Jong=${jong ? `'${jong}'(${jong.charCodeAt(0)})` : 'null'}`);

                    const canActivate = (this.isSameJamo(currentConsonant, cho) || (jong && this.isSameJamo(currentConsonant, jong)));

                    if (!canActivate) {
                        this.showMessage("í˜„ì¬ ìœ„ì¹˜ì˜ ììŒê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤!");
                        this.btnWarp.disabled = true;
                        this.btnMove.disabled = true;
                    } else {
                        // Determine what actions are still available
                        const alreadyWarped = (state.status === 'warped');
                        const alreadyMoved = (state.status === 'moved');

                        // Check Warp Possibility (skip if already warped)
                        let canWarp = false;
                        if (!alreadyWarped && dec.jong) {
                            const target = (this.isSameJamo(currentConsonant, cho)) ? dec.jong : dec.cho;
                            if (target) {
                                const targets = this.findWarpTargets(target.normalize('NFC'));
                                if (targets.length > 0) {
                                    canWarp = true;
                                }
                            }
                        }

                        // Check Move Possibility (skip if already moved)
                        let canMove = !alreadyMoved;

                        // Level type overrides
                        if (this.levelType === 'vowel_only') canWarp = false;
                        if (this.levelType === 'consonant_only') canMove = !alreadyMoved; // move still finishes the letter

                        // If both done, auto-finish this letter
                        if (!canWarp && !canMove) {
                            state.status = 'used';
                            this.hideActionPanel();
                            this.checkWinCondition();
                            return;
                        }

                        this.btnWarp.disabled = !canWarp;
                        this.btnMove.disabled = !canMove;

                        // Show a "ì™„ë£Œ" (finish) button text if one action is already done
                        if (alreadyWarped) {
                            this.showMessage("ì›Œí”„ ì™„ë£Œ! ì´ë™í•˜ê±°ë‚˜ ì™„ë£Œí•˜ì„¸ìš”.");
                            this.btnMove.textContent = 'ëª¨ìŒ\nì´ë™';
                        } else if (alreadyMoved) {
                            this.showMessage(canWarp ? "ì´ë™ ì™„ë£Œ! ì›Œí”„í•˜ê±°ë‚˜ ì™„ë£Œí•˜ì„¸ìš”." : "ì´ë™ ì™„ë£Œ.");
                        } else {
                            if (this.levelType === 'consonant_only') {
                                this.showMessage(canWarp ? "ì›Œí”„ ë˜ëŠ” ê±´ë„ˆë›°ê¸°ë¥¼ ì„ íƒí•˜ì„¸ìš”." : "ì›Œí”„ ëŒ€ìƒì´ ì—†ìŠµë‹ˆë‹¤. 'ì´ë™'ìœ¼ë¡œ ê±´ë„ˆë›°ì„¸ìš”.");
                            } else if (this.levelType === 'vowel_only') {
                                this.showMessage("ëª¨ìŒ ì´ë™ì„ ì„ íƒí•˜ì„¸ìš”.");
                            } else {
                                this.showMessage(canWarp ? "í–‰ë™ì„ ì„ íƒí•˜ì„¸ìš”." : "ì´ë™ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
                            }
                        }
                    }
                }

                hideActionPanel() {
                    this.actionPanel.style.display = 'none';
                    this.selectedBlockIndex = -1;
                    this.renderWordBlocks();
                }
                findWarpTargets(targetConsonant) {
                    const targets = [];
                    const normalizedTarget = targetConsonant.normalize('NFC');
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            const cellConsonant = this.grid[y][x].normalize('NFC');
                            if (this.isSameJamo(cellConsonant, normalizedTarget) && (x !== this.playerPos.x || y !== this.playerPos.y)) {
                                targets.push({ x, y });
                            }
                        }
                    }
                    console.log(`Searching for Warp Target: ${normalizedTarget}(${normalizedTarget.charCodeAt(0)}), Found: ${targets.length}`);
                    return targets;
                }

                initiateWarp() {
                    const state = this.letterStates[this.selectedBlockIndex];
                    if (!state) return;
                    const dec = state.decomposed;
                    const currentConsonant = this.grid[this.playerPos.y][this.playerPos.x].normalize('NFC');
                    const cho = dec.cho.normalize('NFC');
                    const jong = dec.jong ? dec.jong.normalize('NFC') : null;

                    let targetConsonant = "";
                    if (this.isSameJamo(currentConsonant, cho)) targetConsonant = dec.jong;
                    else targetConsonant = dec.cho;

                    const targets = this.findWarpTargets(targetConsonant);
                    if (targets.length === 0) {
                        const msg = `ì›Œí”„í•  '${targetConsonant}'(${targetConsonant.charCodeAt(0)}) ì¹¸ì´ ê·¸ë¦¬ë“œì— ì—†ìŠµë‹ˆë‹¤.`;
                        this.showMessage(msg);
                        console.error(msg);
                        return;
                    }

                    this.showMessage("ë„ì•½í•  ìœ„ì¹˜ë¥¼ í´ë¦­í•˜ì„¸ìš”.");
                    this.highlightCells(targets, 'active');
                    this.isWarping = true;
                    this.actionPanel.style.display = 'none';
                }

                async resolveWarp(targetPos) {
                    this.isWarping = false;
                    this.clearHighlights();

                    this.playerPos = targetPos;
                    this.render();

                    const state = this.letterStates[this.selectedBlockIndex];
                    // If already moved, both actions done â†’ mark as 'used'
                    if (state.status === 'moved') {
                        state.status = 'used';
                        this.hideActionPanel();
                        await this.checkWinCondition();
                    } else {
                        state.status = 'warped';
                        // Show panel again for move
                        if (!await this.checkWinCondition()) {
                            this.selectBlock(this.selectedBlockIndex);
                        }
                    }
                }

                async initiateMove() {
                    const state = this.letterStates[this.selectedBlockIndex];
                    const dec = state.decomposed;

                    // Execute Vowel Move (skip for consonant_only)
                    if (this.levelType !== 'consonant_only') {
                        this.performVowelMove(dec.jung);
                    }

                    // If already warped, both actions done â†’ mark as 'used'
                    if (state.status === 'warped') {
                        state.status = 'used';
                        this.hideActionPanel();
                        await this.checkWinCondition();
                    } else {
                        // Mark as moved, re-show panel for potential warp
                        state.status = 'moved';
                        this.render();
                        if (!await this.checkWinCondition()) {
                            this.selectBlock(this.selectedBlockIndex);
                        }
                    }
                }

                performVowelMove(vowel) {
                    let dx = 0, dy = 0;
                    switch (vowel) {
                        case 'ã…': case 'ã…': dx = 1; break;
                        case 'ã…‘': case 'ã…’': dx = 2; break;
                        case 'ã…“': case 'ã…”': dx = -1; break;
                        case 'ã…•': case 'ã…–': dx = -2; break;
                        case 'ã…—': case 'ã…š': dy = -1; break;
                        case 'ã…›': dy = -2; break;
                        case 'ã…œ': case 'ã…Ÿ': dy = 1; break;
                        case 'ã… ': dy = 2; break;
                        case 'ã…˜': case 'ã…™': dx = 1; dy = -1; break;
                        case 'ã…': case 'ã…': dx = -1; dy = 1; break;
                        default: break;
                    }

                    if (dx !== 0 || dy !== 0) {
                        this.playerPos.x = Math.max(0, Math.min(this.gridSize - 1, this.playerPos.x + dx));
                        this.playerPos.y = Math.max(0, Math.min(this.gridSize - 1, this.playerPos.y + dy));
                        this.render();
                    }
                }

                highlightCells(coords, className) {
                    const cells = this.gridEl.children;
                    coords.forEach(pos => {
                        const idx = pos.y * this.gridSize + pos.x;
                        if (cells[idx]) cells[idx].classList.add(className);
                    });
                }

                clearHighlights() {
                    const cells = this.gridEl.children;
                    for (let i = 0; i < cells.length; i++) {
                        cells[i].classList.remove('active');
                    }
                }

                showMessage(msg) {
                    if (this.messageEl) this.messageEl.textContent = msg;
                }
            }

            window.onload = () => {
                window.game = new GameEngine();
            };
        </script>
</body>

</html>